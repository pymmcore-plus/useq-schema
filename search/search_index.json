{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p> <code>useq-schema</code> is an implementation agnostic schema for describing a sequence of events during a multi-dimensional imaging acquisition. </p> <p>The goal of this repo is to provide a specification (and some python utilities) for generating event objects that can be consumed by microscope acquisition engines. A hope is that this will encourage inter-operability between various efforts to drive automated image acquisition.</p> <p>The schema tries to remain agnostic to the specific acquisition engine (though it was designed based on the capabilities Micro-Manager). We welcome feedback from interested parties regarding limitations and/or potential extensions to the schema! Similarly, while the \"ideal\" schema will support arbitrary dimensions (i.e. more than the conventional position, time, channel, z, ...), it also hard to avoid hard-coding some assumptions about dimensionality in certain places.  Any and all feedback (even minor stuff, such as parameter naming, etc...) is welcome! Please open an issue.</p>"},{"location":"#core-schema","title":"Core Schema","text":""},{"location":"#mdaevent","title":"<code>MDAEvent</code>","text":"<p>The primary \"event\" object is <code>useq.MDAEvent</code>.  This describes a single event that a microscope should perform, including preparation of the hardware, and execution of the event (such as an image acquisition).</p> <ul> <li>For micro-manager, this   object is most similar (though not identical) to the events generated by   <code>generate-acq-sequence</code>   in the clojure acquisition engine that drives Micro-Managers multi-dimensional   acquisitions.</li> <li>For Pycro-manager, this   object is similar to an individual acquisition event   <code>dict</code>   generated by   <code>multi_d_acquisition_events</code>,   (and, <code>useq.pycromanager</code> provides a <code>to_pycromanager</code> method   that returns a dict following the pycro-manager event spec)</li> <li>your object here?...</li> </ul>"},{"location":"#mdasequence","title":"<code>MDASequence</code>","text":"<p><code>useq.MDASequence</code> represents a sequence of events \u2013 as might be generated by the multidimensional acquisition GUI in most microscope software. The Python <code>MDASequence</code> object is itself iterable, and yields <code>useq.MDAEvent</code> objects.</p> <ul> <li>For micro-manager, this   object is most similar to   <code>org.micromanager.acquisition.SequenceSettings</code>,   (generated by clicking the <code>Acquire!</code> button in the Multi-D Acquisition   GUI)</li> <li>For Pycro-manager, this   object is similar to the   <code>multi_d_acquisition_events</code>   convenience function, (and <code>useq.pycromanager</code> provides a   <code>to_pycromanager</code> method that returns a list of pycro-manager event dicts)</li> <li>your object here?...</li> </ul>"},{"location":"#executing-an-mdasequence","title":"Executing an MDASequence","text":"<p>This library is just a schema, and does not provide any built-in functionality for executing an <code>MDASequence</code>.  However, <code>pymmcore-plus</code> implements an acquisition engine that can execute an <code>MDASequence</code> object with micro-manager (via the <code>pymmcore</code> python wrapper around the C++ MMCore).  See the pymmcore-plus documentation for details. <code>napari-micromanager</code> also creates a <code>useq.MDASequence</code> object from user input and passes it to <code>pymmcore-plus</code> for execution.</p> <p>hi! </p> <p>Have you implemented an acquisition engine that can execute a <code>useq.MDASequence</code>? Let us know so we can add it here!</p>"},{"location":"#serialization-and-deserialization","title":"Serialization and Deserialization","text":"<p><code>MDASequence</code> and <code>MDAEvent</code> objects are designed to be serialized and deserialized, allowing you to define an entire multi-dimensional acquisition in human-readable YAML (or JSON) file, and then load that file into your acquisition engine.</p> <p>For example, the following file defines an experiment with:</p> <ul> <li>3 channels (<code>DAPI</code>, <code>FITC</code>, and <code>Cy5</code>), specifying exposure times in ms for each channel</li> <li>a two-phase time-lapse: 3 frames in the first phase, followed by a frame every 10 seconds for 40 minutes</li> <li>a Z-stack at each timepoint, with a range of 4 microns and a step size of 0.5 micron</li> <li>two stage positions, specifying a unique Z-stack for the second position</li> </ul> <p>Example</p> YAMLJSON my_experiment.yaml<pre><code>axis_order: tpcz\nchannels:\n  - config: Cy5\n    exposure: 50.0\n  - config: FITC\n    exposure: 100.0\n  - config: DAPI\n    acquire_every: 3\n    do_stack: false\ntime_plan:\n  phases:\n    - interval: 0:00:03\n      loops: 3\n    - duration: 0:40:00\n      interval: 0:00:10\nz_plan:\n  range: 4.0\n  step: 0.5\nstage_positions:\n  - x: 10.0\n    y: 20.0\n  - name: Cell 1\n    x: 10.0\n    y: 20.0\n    z: 50.0\n    z_plan:\n      above: 10.0\n      below: 0.0\n      step: 1.0\nmetadata:\n  some info: about my experiment\n</code></pre> my_experiment.json<pre><code>{\n  \"axis_order\": \"tpcz\",\n  \"channels\": [\n    {\n      \"config\": \"Cy5\",\n      \"exposure\": 50.0\n    },\n    {\n      \"config\": \"FITC\",\n      \"exposure\": 100.0\n    },\n    {\n      \"config\": \"DAPI\",\n      \"acquire_every\": 3,\n      \"do_stack\": false\n    }\n  ],\n  \"time_plan\": {\n    \"phases\": [\n      {\n        \"interval\": \"0:00:03\",\n        \"loops\": 3\n      },\n      {\n        \"duration\": \"0:40:00\",\n        \"interval\": \"0:00:10\"\n      }\n    ]\n  },\n  \"z_plan\": {\n    \"range\": 4.0,\n    \"step\": 0.5\n  },\n  \"stage_positions\": [\n    {\n      \"x\": 10.0,\n      \"y\": 20.0\n    },\n    {\n      \"name\": \"Cell 1\",\n      \"x\": 10.0,\n      \"y\": 20.0,\n      \"z\": 50.0,\n      \"z_plan\": {\n        \"above\": 10.0,\n        \"below\": 0.0,\n        \"step\": 1.0\n      }\n    }\n  ],\n  \"metadata\": {\n    \"some info\": \"about my experiment\"\n  }\n}\n</code></pre>"},{"location":"api/","title":"API","text":"<p>In addition to declaring a schema (which is intended to be language agnostic), <code>useq-schema</code> offers a python API for working with <code>MDASequence</code> and <code>MDAEvent</code> objects.</p>"},{"location":"api/#useq.MDASequence","title":"<code>MDASequence</code>","text":"<p>A sequence of MDA (Multi-Dimensional Acquisition) events.</p> <p>This is the core object in the <code>useq</code> library, and is used define a sequence of events to be run on a microscope. It object may be constructed manually, or from file (e.g. json or yaml).</p> <p>The object itself acts as an iterator for <code>useq.MDAEvent</code> objects:</p> <p>Attributes:</p> Name Type Description <code>metadata</code> <code>dict</code> <p>A dictionary of user metadata to be stored with the sequence.</p> <code>axis_order</code> <code>str</code> <p>The order of the axes in the sequence. Must be a permutation of <code>\"tpgcz\"</code>. The default is <code>\"tpgcz\"</code>.</p> <code>stage_positions</code> <code>tuple[Position, ...]</code> <p>The stage positions to visit. (each with <code>x</code>, <code>y</code>, <code>z</code>, <code>name</code>, and <code>sequence</code>, all of which are optional).</p> <code>grid_plan</code> <code>GridFromEdges | GridRelative | None</code> <p>The grid plan to follow. One of <code>GridFromEdges</code>, <code>GridRelative</code> or <code>None</code>.</p> <code>channels</code> <code>tuple[Channel, ...]</code> <p>The channels to acquire. see <code>Channel</code>.</p> <code>time_plan</code> <code>MultiPhaseTimePlan | TIntervalDuration | TIntervalLoops | TDurationLoops | None</code> <p>The time plan to follow. One of <code>TIntervalDuration</code>, <code>TIntervalLoops</code>, <code>TDurationLoops</code>, <code>MultiPhaseTimePlan</code>, or <code>None</code></p> <code>z_plan</code> <code>ZTopBottom | ZRangeAround | ZAboveBelow | ZRelativePositions | ZAbsolutePositions | None</code> <p>The z plan to follow. One of <code>ZTopBottom</code>, <code>ZRangeAround</code>, <code>ZAboveBelow</code>, <code>ZRelativePositions</code>, <code>ZAbsolutePositions</code>, or <code>None</code>.</p> <code>uid</code> <code>UUID</code> <p>A read-only unique identifier (uuid version 4) for the sequence. This will be generated, do not set.</p> <code>autofocus_plan</code> <code>AxesBasedAF | None</code> <p>The hardware autofocus plan to follow. One of <code>AxesBasedAF</code> or <code>None</code>.</p> <code>keep_shutter_open_across</code> <code>tuple[str, ...]</code> <p>A tuple of axes <code>str</code> across which the illumination shutter should be kept open. Resulting events will have <code>keep_shutter_open</code> set to <code>True</code> if and only if ALL axes whose indices are changing are in this tuple. For example, if <code>keep_shutter_open_across=('z',)</code>, then the shutter would be kept open between events axes {'t': 0, 'z: 0} and {'t': 0, 'z': 1}, but not between {'t': 0, 'z': 0} and {'t': 1, 'z': 0}.</p> <p>Examples:</p> <p>Create a MDASequence</p> <pre><code>&gt;&gt;&gt; from useq import MDASequence, Position, Channel, TIntervalDuration\n&gt;&gt;&gt; seq = MDASequence(\n...     axis_order=\"tpgcz\",\n...     time_plan={\"interval\": 0.1, \"loops\": 2},\n...     stage_positions=[(1, 1, 1)],\n...     grid_plan={\"rows\": 2, \"columns\": 2},\n...     z_plan={\"range\": 3, \"step\": 1},\n...     channels=[{\"config\": \"DAPI\", \"exposure\": 1}]\n... )\n</code></pre> <p>Print the sequence to visualize its structure</p> <pre><code>&gt;&gt;&gt; print(seq)\n... MDASequence(\n...     stage_positions=(Position(x=1.0, y=1.0, z=1.0, name=None),),\n...     grid_plan=GridRowsColumns(\n...         fov_width=None,\n...         fov_height=None,\n...         overlap=(0.0, 0.0),\n...         mode=&lt;OrderMode.row_wise_snake: 'row_wise_snake'&gt;,\n...         rows=2,\n...         columns=2,\n...         relative_to=&lt;RelativeTo.center: 'center'&gt;\n...     ),\n...     channels=(\n...         Channel(\n...             config='DAPI',\n...             group='Channel',\n...             exposure=1.0,\n...             do_stack=True,\n...             z_offset=0.0,\n...             acquire_every=1,\n...             camera=None\n...         ),\n...     ),\n...     time_plan=TIntervalLoops(\n...         prioritize_duration=False,\n...         interval=datetime.timedelta(microseconds=100000),\n...         loops=2\n...     ),\n...     z_plan=ZRangeAround(go_up=True, range=3.0, step=1.0)\n... )\n</code></pre> <p>Iterate over the events in the sequence</p> <pre><code>&gt;&gt;&gt; print(list(seq))\n... [\n...     MDAEvent(\n...         index=mappingproxy({'t': 0, 'p': 0, 'g': 0, 'c': 0, 'z': 0}),\n...         channel=Channel(config='DAPI'),\n...         exposure=1.0,\n...         min_start_time=0.0,\n...         x_pos=0.5,\n...         y_pos=1.5,\n...         z_pos=-0.5\n...     ),\n...     MDAEvent(\n...         index=mappingproxy({'t': 0, 'p': 0, 'g': 0, 'c': 0, 'z': 1}),\n...         channel=Channel(config='DAPI'),\n...         exposure=1.0,\n...         min_start_time=0.0,\n...         x_pos=0.5,\n...         y_pos=1.5,\n...         z_pos=0.5\n...     ),\n...     ...\n... ]\n</code></pre> <p>Print the sequence as yaml</p> <pre><code>&gt;&gt;&gt; print(seq.yaml())\n</code></pre> <pre><code>axis_order:\n   - t\n   - p\n   - g\n   - c\n   - z\nchannels:\n   - config: DAPI\n     exposure: 1.0\ngrid_plan:\n   columns: 2\n   rows: 2\nstage_positions:\n   - x: 1.0\n     y: 1.0\n     z: 1.0\ntime_plan:\n   interval: '0:00:00.100000'\n   loops: 2\nz_plan:\n   range: 3.0\n   step: 1.0\n</code></pre>"},{"location":"api/#useq.MDASequence.shape","title":"<code>shape: tuple[int, ...]</code>  <code>property</code>","text":"<p>Return the shape of this sequence.</p> <p>Note</p> <p>This doesn't account for jagged arrays, like channels that exclude z stacks or skip timepoints.</p>"},{"location":"api/#useq.MDASequence.sizes","title":"<code>sizes: Mapping[str, int]</code>  <code>property</code>","text":"<p>Mapping of axis name to size of that axis.</p>"},{"location":"api/#useq.MDASequence.uid","title":"<code>uid: UUID</code>  <code>property</code>","text":"<p>A unique identifier for this sequence.</p>"},{"location":"api/#useq.MDASequence.used_axes","title":"<code>used_axes: str</code>  <code>property</code>","text":"<p>Single letter string of axes used in this sequence, e.g. <code>ztc</code>.</p>"},{"location":"api/#useq.MDASequence.__eq__","title":"<code>__eq__(other: Any) -&gt; bool</code>","text":"<p>Return <code>True</code> if two <code>MDASequences</code> are equal (uid is excluded).</p>"},{"location":"api/#useq.MDASequence.__iter__","title":"<code>__iter__() -&gt; Iterator[MDAEvent]</code>","text":"<p>Same as <code>iter_events</code>. Supports <code>for event in sequence: ...</code> syntax.</p>"},{"location":"api/#useq.MDASequence.estimate_duration","title":"<code>estimate_duration() -&gt; TimeEstimate</code>","text":"<p>Estimate duration and other timing issues of an MDASequence.</p> <p>Notable mis-estimations may include: - when the time interval is shorter than the time it takes to acquire the data and any of the channels have <code>acquire_every</code> &gt; 1 - when channel exposure times are omitted. In this case, we assume 1ms exposure.</p> <p>Returns:</p> Type Description <code>TimeEstimate</code> <p>A named 3-tuple with the following fields: - total_duration: float     Estimated total duration of the experiment, in seconds. - per_t_duration: float     Estimated duration of a single timepoint, in seconds. - time_interval_exceeded: bool     Whether the time interval between timepoints is shorter than the time it     takes to acquire the data</p>"},{"location":"api/#useq.MDASequence.iter_axis","title":"<code>iter_axis(axis: str) -&gt; Iterator[Channel | float | PositionBase]</code>","text":"<p>Iterate over the positions or items of a given axis.</p>"},{"location":"api/#useq.MDASequence.iter_events","title":"<code>iter_events() -&gt; Iterator[MDAEvent]</code>","text":"<p>Iterate over all events in the MDA sequence.</p> <p>See source of useq._mda_sequence.iter_sequence for details on how events are constructed and yielded.</p> <p>Yields:</p> Type Description <code>MDAEvent</code> <p>Each event in the MDA sequence.</p>"},{"location":"api/#useq._mda_sequence.iter_sequence","title":"<code>iter_sequence(sequence)</code>","text":"<p>Iterate over all events in the MDA sequence.'.</p> <p>Note</p> <p>This method will usually be used via <code>useq.MDASequence.iter_events</code>, or by simply iterating over the sequence.</p> <p>This does the job of iterating over all the frames in the MDA sequence, handling the logic of merging all z plans in channels and stage positions defined in the plans for each axis.</p> <p>The is the most \"logic heavy\" part of <code>useq-schema</code> (the rest of which is almost entirely declarative).  This iterator is useful for consuming <code>MDASequence</code> objects in a python runtime, but it isn't considered a \"core\" part of the schema.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>MDASequence</code> <p>The sequence to iterate over.</p> required <p>Yields:</p> Type Description <code>MDAEvent</code> <p>Each event in the MDA sequence.</p> Source code in <code>src/useq/_iter_sequence.py</code> <pre><code>def iter_sequence(sequence: MDASequence) -&gt; Iterator[MDAEvent]:\n    \"\"\"Iterate over all events in the MDA sequence.'.\n\n    !!! note\n        This method will usually be used via [`useq.MDASequence.iter_events`][], or by\n        simply iterating over the sequence.\n\n    This does the job of iterating over all the frames in the MDA sequence,\n    handling the logic of merging all z plans in channels and stage positions\n    defined in the plans for each axis.\n\n    The is the most \"logic heavy\" part of `useq-schema` (the rest of which is\n    almost entirely declarative).  This iterator is useful for consuming `MDASequence`\n    objects in a python runtime, but it isn't considered a \"core\" part of the schema.\n\n    Parameters\n    ----------\n    sequence : MDASequence\n        The sequence to iterate over.\n\n    Yields\n    ------\n    MDAEvent\n        Each event in the MDA sequence.\n    \"\"\"\n    if not (keep_shutter_open_axes := sequence.keep_shutter_open_across):\n        yield from _iter_sequence(sequence)\n        return\n\n    it = _iter_sequence(sequence)\n    if (this_e := next(it, None)) is None:  # pragma: no cover\n        return\n\n    for next_e in it:\n        # set `keep_shutter_open` to `True` if and only if ALL axes whose index\n        # changes betwee this_event and next_event are in `keep_shutter_open_axes`\n        if all(\n            axis in keep_shutter_open_axes\n            for axis, idx in this_e.index.items()\n            if idx != next_e.index[axis]\n        ):\n            this_e = this_e.model_copy(update={\"keep_shutter_open\": True})\n        yield this_e\n        this_e = next_e\n    yield this_e\n</code></pre>"},{"location":"schema/axes/","title":"Axes","text":"<p>The following objects may be used to describe iteration over specific types of dimensions.</p>"},{"location":"schema/axes/#useq.Position","title":"<code>Position = AbsolutePosition</code>  <code>module-attribute</code>","text":""},{"location":"schema/axes/#useq.Channel","title":"<code>Channel</code>","text":"<p>Define an acquisition channel.</p> <p>Attributes:</p> Name Type Description <code>config</code> <code>str</code> <p>Name of the configuration to use for this channel, (e.g. <code>\"488nm\"</code>, <code>\"DAPI\"</code>, <code>\"FITC\"</code>).</p> <code>group</code> <code>str</code> <p>Optional name of the group to which this channel belongs. By default, <code>\"Channel\"</code>.</p> <code>exposure</code> <code>float | None</code> <p>Exposure time in milliseconds. Must be positive.  If not provided, implies use current exposure time. By default, <code>None</code>.</p> <code>do_stack</code> <code>bool</code> <p>If <code>True</code>, instructs engine to include this channel in any Z stacks being acquired. By default, <code>True</code>.</p> <code>z_offset</code> <code>float</code> <p>Relative Z offset from current position, in microns. By default, <code>0</code>.</p> <code>acquire_every</code> <code>int</code> <p>Acquire every Nth frame (if acquiring a time series). By default, <code>1</code>.</p> <code>camera</code> <code>str | None</code> <p>Name of the camera to use for this channel. If not provided, implies use current camera. By default, <code>None</code>.</p>"},{"location":"schema/axes/#time-plans","title":"Time Plans","text":"<p>Ways to describe a temporal acquisition sequence.</p>"},{"location":"schema/axes/#useq.TIntervalDuration","title":"<code>TIntervalDuration</code>","text":"<p>Define temporal sequence using interval and duration.</p> <p>Attributes:</p> Name Type Description <code>interval</code> <code>str | timedelta</code> <p>Time between frames. Scalars are interpreted as seconds. Strings are parsed according to ISO 8601.</p> <code>duration</code> <code>str | timedelta</code> <p>Total duration of sequence.</p> <code>prioritize_duration</code> <code>bool</code> <p>If <code>True</code>, instructs engine to prioritize duration over number of frames in case of conflict. By default, <code>True</code>.</p>"},{"location":"schema/axes/#useq.TIntervalLoops","title":"<code>TIntervalLoops</code>","text":"<p>Define temporal sequence using interval and number of loops.</p> <p>Attributes:</p> Name Type Description <code>interval</code> <code>str | timedelta | float</code> <p>Time between frames. Scalars are interpreted as seconds. Strings are parsed according to ISO 8601.</p> <code>loops</code> <code>int</code> <p>Number of frames.</p> <code>prioritize_duration</code> <code>bool</code> <p>If <code>True</code>, instructs engine to prioritize duration over number of frames in case of conflict. By default, <code>False</code>.</p>"},{"location":"schema/axes/#useq.TDurationLoops","title":"<code>TDurationLoops</code>","text":"<p>Define temporal sequence using duration and number of loops.</p> <p>Attributes:</p> Name Type Description <code>duration</code> <code>str | timedelta</code> <p>Total duration of sequence. Scalars are interpreted as seconds. Strings are parsed according to ISO 8601.</p> <code>loops</code> <code>int</code> <p>Number of frames.</p> <code>prioritize_duration</code> <code>bool</code> <p>If <code>True</code>, instructs engine to prioritize duration over number of frames in case of conflict. By default, <code>False</code>.</p>"},{"location":"schema/axes/#useq.TIntervalDuration","title":"<code>TIntervalDuration</code>","text":"<p>Define temporal sequence using interval and duration.</p> <p>Attributes:</p> Name Type Description <code>interval</code> <code>str | timedelta</code> <p>Time between frames. Scalars are interpreted as seconds. Strings are parsed according to ISO 8601.</p> <code>duration</code> <code>str | timedelta</code> <p>Total duration of sequence.</p> <code>prioritize_duration</code> <code>bool</code> <p>If <code>True</code>, instructs engine to prioritize duration over number of frames in case of conflict. By default, <code>True</code>.</p>"},{"location":"schema/axes/#useq.MultiPhaseTimePlan","title":"<code>MultiPhaseTimePlan</code>","text":"<p>Time sequence composed of multiple phases.</p> <p>Attributes:</p> Name Type Description <code>phases</code> <code>Sequence[TIntervalDuration | TIntervalLoops | TDurationLoops]</code> <p>Sequence of time plans.</p>"},{"location":"schema/axes/#z-plans","title":"Z Plans","text":"<p>Ways to describe a z-stack acquisition sequence.</p>"},{"location":"schema/axes/#useq.ZTopBottom","title":"<code>ZTopBottom</code>","text":"<p>Define Z using absolute top &amp; bottom positions.</p> <p>Note that <code>bottom</code> will always be visited, regardless of <code>go_up</code>, while <code>top</code> will always be encompassed by the range, but may not be precisely visited if the step size does not divide evenly into the range.</p> <p>Attributes:</p> Name Type Description <code>top</code> <code>float</code> <p>Top position in microns (inclusive).</p> <code>bottom</code> <code>float</code> <p>Bottom position in microns (inclusive).</p> <code>step</code> <code>float</code> <p>Step size in microns.</p> <code>go_up</code> <code>bool</code> <p>If <code>True</code>, instructs engine to start at bottom and move towards top. By default, <code>True</code>.</p>"},{"location":"schema/axes/#useq.ZAboveBelow","title":"<code>ZAboveBelow</code>","text":"<p>Define Z as asymmetric range above and below some reference position.</p> <p>Note that <code>below</code> will always be visited, regardless of <code>go_up</code>, while <code>above</code> will always be encompassed by the range, but may not be precisely visited if the step size does not divide evenly into the range.</p> <p>Attributes:</p> Name Type Description <code>above</code> <code>float</code> <p>Range above reference position in microns (inclusive).</p> <code>below</code> <code>float</code> <p>Range below reference position in microns (inclusive).</p> <code>step</code> <code>float</code> <p>Step size in microns.</p> <code>go_up</code> <code>bool</code> <p>If <code>True</code>, instructs engine to start at bottom and move towards top. By default, <code>True</code>.</p>"},{"location":"schema/axes/#useq.ZAbsolutePositions","title":"<code>ZAbsolutePositions</code>","text":"<p>Define Z as a list of absolute positions.</p> <p>Attributes:</p> Name Type Description <code>relative</code> <code>list[float]</code> <p>List of relative z positions.</p> <code>go_up</code> <code>bool</code> <p>If <code>True</code> (the default), visits points in the order provided, otherwise in reverse.</p>"},{"location":"schema/axes/#useq.ZRangeAround","title":"<code>ZRangeAround</code>","text":"<p>Define Z as a symmetric range around some reference position.</p> <p>Note that <code>-range / 2</code> will always be visited, regardless of <code>go_up</code>, while <code>+range / 2</code> will always be encompassed by the range, but may not be precisely visited if the step size does not divide evenly into the range.</p> <p>Attributes:</p> Name Type Description <code>range</code> <code>float</code> <p>Range in microns (inclusive). For example, a range of 4 with a step size of 1 would visit [-2, -1, 0, 1, 2].</p> <code>step</code> <code>float</code> <p>Step size in microns.</p> <code>go_up</code> <code>bool</code> <p>If <code>True</code>, instructs engine to start at bottom and move towards top. By default, <code>True</code>.</p>"},{"location":"schema/axes/#useq.ZRelativePositions","title":"<code>ZRelativePositions</code>","text":"<p>Define Z as a list of positions relative to some reference.</p> <p>Typically, the \"reference\" will be whatever the current Z position is at the start of the sequence.</p> <p>Attributes:</p> Name Type Description <code>relative</code> <code>list[float]</code> <p>List of relative z positions.</p> <code>go_up</code> <code>bool</code> <p>If <code>True</code> (the default), visits points in the order provided, otherwise in reverse.</p>"},{"location":"schema/axes/#grid-plans","title":"Grid Plans","text":"<p>Ways to describe a grid acquisition sequence.</p>"},{"location":"schema/axes/#useq.GridRowsColumns","title":"<code>GridRowsColumns</code>","text":"<p>Grid plan based on number of rows and columns.</p> <p>Attributes:</p> Name Type Description <code>rows</code> <code>int</code> <p>Number of rows.</p> <code>columns</code> <code>int</code> <p>Number of columns.</p> <code>relative_to</code> <code>RelativeTo</code> <p>Point in the grid to which the coordinates are relative. If \"center\", the grid is centered around the origin. If \"top_left\", the grid is positioned such that the top left corner is at the origin.</p> <code>overlap</code> <code>float | Tuple[float, float]</code> <p>Overlap between grid positions in percent. If a single value is provided, it is used for both x and y. If a tuple is provided, the first value is used for x and the second for y.</p> <code>mode</code> <code>OrderMode</code> <p>Define the ways of ordering the grid positions. Options are row_wise, column_wise, row_wise_snake, column_wise_snake and spiral. By default, row_wise_snake.</p> <code>fov_width</code> <code>Optional[float]</code> <p>Width of the field of view in microns.  If not provided, acquisition engines should use current width of the FOV based on the current objective and camera. Engines MAY override this even if provided.</p> <code>fov_height</code> <code>Optional[float]</code> <p>Height of the field of view in microns. If not provided, acquisition engines should use current height of the FOV based on the current objective and camera. Engines MAY override this even if provided.</p>"},{"location":"schema/axes/#useq.GridWidthHeight","title":"<code>GridWidthHeight</code>","text":"<p>Grid plan based on total width and height.</p> <p>Attributes:</p> Name Type Description <code>width</code> <code>float</code> <p>Minimum total width of the grid, in microns. (may be larger based on fov_width)</p> <code>height</code> <code>float</code> <p>Minimum total height of the grid, in microns. (may be larger based on fov_height)</p> <code>relative_to</code> <code>RelativeTo</code> <p>Point in the grid to which the coordinates are relative. If \"center\", the grid is centered around the origin. If \"top_left\", the grid is positioned such that the top left corner is at the origin.</p> <code>overlap</code> <code>float | Tuple[float, float]</code> <p>Overlap between grid positions in percent. If a single value is provided, it is used for both x and y. If a tuple is provided, the first value is used for x and the second for y.</p> <code>mode</code> <code>OrderMode</code> <p>Define the ways of ordering the grid positions. Options are row_wise, column_wise, row_wise_snake, column_wise_snake and spiral. By default, row_wise_snake.</p> <code>fov_width</code> <code>Optional[float]</code> <p>Width of the field of view in microns.  If not provided, acquisition engines should use current width of the FOV based on the current objective and camera. Engines MAY override this even if provided.</p> <code>fov_height</code> <code>Optional[float]</code> <p>Height of the field of view in microns. If not provided, acquisition engines should use current height of the FOV based on the current objective and camera. Engines MAY override this even if provided.</p>"},{"location":"schema/axes/#useq.GridFromEdges","title":"<code>GridFromEdges</code>","text":"<p>Yield absolute stage positions to cover a bounded area.</p> <p>The bounded area is defined by top, left, bottom and right edges in stage coordinates.  The bounds define the outer edges of the images, including the field of view and overlap.</p> <p>Attributes:</p> Name Type Description <code>top</code> <code>float</code> <p>Top stage position of the bounding area</p> <code>left</code> <code>float</code> <p>Left stage position of the bounding area</p> <code>bottom</code> <code>float</code> <p>Bottom stage position of the bounding area</p> <code>right</code> <code>float</code> <p>Right stage position of the bounding area</p> <code>overlap</code> <code>float | Tuple[float, float]</code> <p>Overlap between grid positions in percent. If a single value is provided, it is used for both x and y. If a tuple is provided, the first value is used for x and the second for y.</p> <code>mode</code> <code>OrderMode</code> <p>Define the ways of ordering the grid positions. Options are row_wise, column_wise, row_wise_snake, column_wise_snake and spiral. By default, row_wise_snake.</p> <code>fov_width</code> <code>Optional[float]</code> <p>Width of the field of view in microns.  If not provided, acquisition engines should use current width of the FOV based on the current objective and camera. Engines MAY override this even if provided.</p> <code>fov_height</code> <code>Optional[float]</code> <p>Height of the field of view in microns. If not provided, acquisition engines should use current height of the FOV based on the current objective and camera. Engines MAY override this even if provided.</p>"},{"location":"schema/axes/#useq.RandomPoints","title":"<code>RandomPoints</code>","text":"<p>Yield random points in a specified geometric shape.</p> <p>Attributes:</p> Name Type Description <code>num_points</code> <code>int</code> <p>Number of points to generate.</p> <code>max_width</code> <code>float</code> <p>Maximum width of the bounding box in microns.</p> <code>max_height</code> <code>float</code> <p>Maximum height of the bounding box in microns.</p> <code>shape</code> <code>Shape</code> <p>Shape of the bounding box. Current options are \"ellipse\" and \"rectangle\".</p> <code>random_seed</code> <code>Optional[int]</code> <p>Random numpy seed that should be used to generate the points. If None, a random seed will be used.</p> <code>allow_overlap</code> <code>bool</code> <p>By defaut, True. If False and <code>fov_width</code> and <code>fov_height</code> are specified, points will not overlap and will be at least <code>fov_width</code> and `fov_height apart.</p> <code>order</code> <code>TraversalOrder</code> <p>Order in which the points will be visited. If None, order is simply the order in which the points are generated (random).  Use 'nearest_neighbor' or 'two_opt' to order the points in a more structured way.</p> <code>start_at</code> <code>int | RelativePosition</code> <p>Position or index of the point to start at. This is only used if <code>order</code> is 'nearest_neighbor' or 'two_opt'.  If a position is provided, it will always be included in the list of points. If an index is provided, it must be less than the number of points, and corresponds to the index of the (randomly generated) points; this likely only makes sense when <code>random_seed</code> is provided.</p>"},{"location":"schema/axes/#useq._grid.RelativeTo","title":"<code>RelativeTo</code>","text":"<p>Where the coordinates of the grid are relative to.</p> <p>Attributes:</p> Name Type Description <code>center</code> <code>Literal['center']</code> <p>Grid is centered around the origin.</p> <code>top_left</code> <code>Literal['top_left']</code> <p>Grid is positioned such that the top left corner is at the origin.</p>"},{"location":"schema/axes/#useq._grid.OrderMode","title":"<code>OrderMode</code>","text":"<p>Order in which grid positions will be iterated.</p> <p>Attributes:</p> Name Type Description <code>row_wise</code> <code>Literal['row_wise']</code> <p>Iterate row by row.</p> <code>column_wise</code> <code>Literal['column_wise']</code> <p>Iterate column by column.</p> <code>row_wise_snake</code> <code>Literal['row_wise_snake']</code> <p>Iterate row by row, but alternate the direction of the columns.</p> <code>column_wise_snake</code> <code>Literal['column_wise_snake']</code> <p>Iterate column by column, but alternate the direction of the rows.</p> <code>spiral</code> <code>Literal['spiral']</code> <p>Iterate in a spiral pattern, starting from the center.</p>"},{"location":"schema/axes/#useq._grid.OrderMode.generate_indices","title":"<code>generate_indices</code>","text":"<p>Generate indices for the given grid size.</p>"},{"location":"schema/axes/#useq._grid.Shape","title":"<code>Shape</code>","text":"<p>Shape of the bounding box for random points.</p> <p>Attributes:</p> Name Type Description <code>ELLIPSE</code> <code>Literal['ellipse']</code> <p>The bounding box is an ellipse.</p> <code>RECTANGLE</code> <code>Literal['rectangle']</code> <p>The bounding box is a rectangle.</p>"},{"location":"schema/event/","title":"Event","text":""},{"location":"schema/event/#useq.MDAEvent","title":"<code>MDAEvent</code>","text":"<p>Define a single event in a <code>MDASequence</code>.</p> <p>Usually, this object will be generator by iterating over a <code>MDASequence</code> (see <code>useq.MDASequence.iter_events</code>).</p> <p>Attributes:</p> Name Type Description <code>index</code> <code>dict[str, int]</code> <p>Index of this event in the sequence. This is a mapping of axis name to index.  For example: <code>{'t': 4, 'c': 0, 'z': 5},</code></p> <code>channel</code> <code>Channel | None</code> <p>Channel to use for this event. If <code>None</code>, implies use current channel. By default, <code>None</code>.  <code>Channel</code> is a simple pydantic object with two attributes: <code>config</code> and <code>group</code>.  <code>config</code> is the name of the configuration to use for this channel, (e.g. <code>\"488nm\"</code>, <code>\"DAPI\"</code>, <code>\"FITC\"</code>).  <code>group</code> is the name of the group to which this channel belongs. By default, <code>\"Channel\"</code>.</p> <code>exposure</code> <code>float | None</code> <p>Exposure time in milliseconds. If not provided, implies use current exposure time. By default, <code>None</code>.</p> <code>min_start_time</code> <code>float | None</code> <p>Minimum start time of this event, in seconds.  If provided, the engine will pause until this time has elapsed before starting this event. Times are relative to the start of the sequence, or the last event with <code>reset_event_timer</code> set to <code>True</code>.</p> <code>pos_name</code> <code>str | None</code> <p>The name assigned to the position. By default, <code>None</code>.</p> <code>x_pos</code> <code>float | None</code> <p>X position in microns. If not provided, implies use current position. By default, <code>None</code>.</p> <code>y_pos</code> <code>float | None</code> <p>Y position in microns. If not provided, implies use current position. By default, <code>None</code>.</p> <code>z_pos</code> <code>float | None</code> <p>Z position in microns. If not provided, implies use current position. By default, <code>None</code>.</p> <code>slm_image</code> <code>SLMImage | None</code> <p>Image data to display on an SLM device. <code>SLMImage</code> is a simple pydantic object with two attributes: <code>data</code> and <code>device</code>. <code>data</code> is the image data (anything that can be cast to a numpy array), <code>device</code> is the name of the SLM device to use. If not provided, the \"default\" SLM device should be used. By default, <code>None</code>.</p> <code>sequence</code> <code>MDASequence | None</code> <p>A reference to the <code>useq.MDASequence</code> this event belongs to. This is a read-only attribute. By default, <code>None</code>.</p> <code>properties</code> <code>Sequence[PropertyTuple] | None</code> <p>List of <code>useq.PropertyTuple</code> to set before starting this event. Where each item in the list is a 3-member named tuple of <code>(device_name, property_name, property_value)</code>.  This is inspired by micro-manager's Device Adapter API, but could be used to set arbitrary properties in any backend that supports the concept of devices that have properties with values. By default, <code>None</code>.</p> <code>metadata</code> <code>dict</code> <p>Optional metadata to be associated with this event.</p> <code>action</code> <code>Action</code> <p>The action to perform for this event.  By default, <code>useq.AcquireImage</code>. Example of another action is <code>useq.HardwareAutofocus</code> which could be used to perform a hardware autofocus.  For backwards compatibility, an <code>action</code> of <code>None</code> implies <code>AcquireImage</code>.  You may use <code>CustomAction</code> to indicate any custom action, with the <code>data</code> attribute containing any data required to perform the custom action.</p> <code>keep_shutter_open</code> <code>bool</code> <p>If <code>True</code>, the illumination shutter should be left open after the event has been executed, otherwise it should be closed. By default, <code>False</code>.\" This is useful when the sequence of events being executed use the same illumination scheme (such as a z-stack in a single channel), and closing and opening the shutter between events would be slow.</p> <code>reset_event_timer</code> <code>bool</code> <p>If <code>True</code>, the engine should reset the event timer to the time of this event, and future <code>min_start_time</code> values will be relative to this event. By default, <code>False</code>.</p>"},{"location":"schema/event/#useq._mda_event.Channel","title":"<code>Channel</code>","text":"<p>Channel in a MDA event.</p> <p>Attributes:</p> Name Type Description <code>config</code> <code>str</code> <p>Name of the configuration to use for this channel, (e.g. <code>\"488nm\"</code>, <code>\"DAPI\"</code>, <code>\"FITC\"</code>).</p> <code>group</code> <code>str</code> <p>Optional name of the group to which this channel belongs. By default, <code>\"Channel\"</code>.</p>"},{"location":"schema/event/#useq.PropertyTuple","title":"<code>PropertyTuple</code>","text":"<p>Three-tuple capturing a device, property, and value.</p> <p>Attributes:</p> Name Type Description <code>device_name</code> <code>str</code> <p>Name of a device.</p> <code>property_name</code> <code>str</code> <p>Name of a property recognized by the device.</p> <code>value</code> <code>Any</code> <p>Value for the property.</p>"},{"location":"schema/event/#event-actions","title":"Event Actions","text":""},{"location":"schema/event/#useq.Action","title":"<code>Action</code>","text":"<p>Base class for a <code>useq.MDAEvent</code> action.</p> <p>An <code>Action</code> specifies what task should be performed during a <code>useq.MDAEvent</code>. An <code>Action</code> can be for example used to acquire an image (<code>useq.AcquireImage</code>) or to perform a hardware autofocus (<code>useq.HardwareAutofocus</code>).  An action of <code>None</code> implies <code>AcquireImage</code>.</p> <p>You may use <code>CustomAction</code> to indicate any custom action, with the <code>data</code> attribute containing any data required to perform the custom action.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>str</code> <p>Type of the action that should be performed at the <code>useq.MDAEvent</code>.</p>"},{"location":"schema/event/#useq.AcquireImage","title":"<code>AcquireImage</code>","text":"<p><code>useq.Action</code> to acquire an image.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>Literal['acquire_image']</code> <p>This action can be used to acquire an image.</p>"},{"location":"schema/event/#useq.HardwareAutofocus","title":"<code>HardwareAutofocus</code>","text":"<p><code>useq.Action</code> to perform a hardware autofocus.</p> <p>See also <code>useq.AutoFocusPlan</code>.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>Literal['hardware_autofocus']</code> <p>This action can be used to trigger hardware autofocus.</p> <code>autofocus_device_name</code> <code>(str, optional)</code> <p>The name of the autofocus offset motor device (if applicable).  If <code>None</code>, acquisition engines may attempt to set the offset however they see fit (such as using a current or default autofocus device.)</p> <code>autofocus_motor_offset</code> <code>(float, optional)</code> <p>Before autofocus is performed, the autofocus motor should be moved to this offset, if applicable. (Not all autofocus devices have an offset motor.) If None, the autofocus motor should not be moved.</p> <code>max_retries</code> <code>int</code> <p>The number of retries if autofocus fails. By default, 3.</p>"},{"location":"schema/hardware_autofocus/","title":"Hardware Autofocus Plan","text":"<p>Ways to describe a hardware-based autofocus plan.</p>"},{"location":"schema/hardware_autofocus/#useq.AutoFocusPlan","title":"<code>AutoFocusPlan</code>","text":"<p>Base class for hardware autofocus plans.</p> <p>Attributes:</p> Name Type Description <code>autofocus_device_name</code> <code>str | None</code> <p>Optional name of the offset motor device.  If <code>None</code>, acquisition engines may attempt to set the offset however they see fit (such as using a current or default autofocus device.)</p> <code>autofocus_motor_offset</code> <code>float | None</code> <p>Before autofocus is performed, the autofocus motor should be moved to this offset, if applicable. (Not all autofocus devices have an offset motor.) If None, the autofocus motor should not be moved.</p>"},{"location":"schema/hardware_autofocus/#useq.AutoFocusPlan.as_action","title":"<code>as_action() -&gt; HardwareAutofocus</code>","text":"<p>Return a <code>useq.HardwareAutofocus</code> for this autofocus plan.</p>"},{"location":"schema/hardware_autofocus/#useq.AutoFocusPlan.event","title":"<code>event(event: MDAEvent) -&gt; Optional[MDAEvent]</code>","text":"<p>Return an autofocus <code>useq.MDAEvent</code> if autofocus should be performed.</p> <p>The z position of the new <code>useq.MDAEvent</code> is also updated if a relative zplan is provided since autofocus shuld be performed on the home z stack position.</p>"},{"location":"schema/hardware_autofocus/#useq.AutoFocusPlan.should_autofocus","title":"<code>should_autofocus(event: MDAEvent) -&gt; bool</code>","text":"<p>Method that must be implemented by a subclass.</p> <p>Should return True if autofocus should be performed (see <code>useq.AxesBasedAF</code>).</p>"},{"location":"schema/hardware_autofocus/#useq.AxesBasedAF","title":"<code>AxesBasedAF</code>","text":"<p>Autofocus plan that performs autofocus when any of the specified axes change.</p> <p>Attributes:</p> Name Type Description <code>axes</code> <code>Tuple[str, ...]</code> <p>Tuple of axis label to use for hardware autofocus.  At every event in which any axis in this tuple is change, autofocus will be performed.  For example, if <code>axes</code> is <code>('p',)</code> then autofocus will be performed every time the <code>p</code> axis is change, (in other words: every time the position is changed.).</p> Source code in <code>src/useq/_hardware_autofocus.py</code> <pre><code>class AxesBasedAF(AutoFocusPlan):\n    \"\"\"Autofocus plan that performs autofocus when any of the specified axes change.\n\n    Attributes\n    ----------\n    axes : Tuple[str, ...]\n        Tuple of axis label to use for hardware autofocus.  At every event in which\n        *any* axis in this tuple is change, autofocus will be performed.  For example,\n        if `axes` is `('p',)` then autofocus will be performed every time the `p` axis\n        is change, (in other words: every time the position is changed.).\n    \"\"\"\n\n    axes: tuple[str, ...]\n    _previous: dict = PrivateAttr(default_factory=dict)\n\n    def should_autofocus(self, event: MDAEvent) -&gt; bool:\n        \"\"\"Return `True` if autofocus should be performed at this event.\n\n        Will return `True` if any of the axes specified in `axes` have changed from the\n        previous event.\n        \"\"\"\n        self._previous, previous = dict(event.index), self._previous\n        return any(\n            axis in self.axes and previous.get(axis) != index\n            for axis, index in event.index.items()\n        )\n</code></pre>"},{"location":"schema/hardware_autofocus/#useq.AxesBasedAF.should_autofocus","title":"<code>should_autofocus(event: MDAEvent) -&gt; bool</code>","text":"<p>Return <code>True</code> if autofocus should be performed at this event.</p> <p>Will return <code>True</code> if any of the axes specified in <code>axes</code> have changed from the previous event.</p> Source code in <code>src/useq/_hardware_autofocus.py</code> <pre><code>def should_autofocus(self, event: MDAEvent) -&gt; bool:\n    \"\"\"Return `True` if autofocus should be performed at this event.\n\n    Will return `True` if any of the axes specified in `axes` have changed from the\n    previous event.\n    \"\"\"\n    self._previous, previous = dict(event.index), self._previous\n    return any(\n        axis in self.axes and previous.get(axis) != index\n        for axis, index in event.index.items()\n    )\n</code></pre>"},{"location":"schema/sequence/","title":"Sequence","text":""},{"location":"schema/sequence/#useq.MDASequence","title":"<code>MDASequence</code>","text":"<p>A sequence of MDA (Multi-Dimensional Acquisition) events.</p> <p>This is the core object in the <code>useq</code> library, and is used define a sequence of events to be run on a microscope. It object may be constructed manually, or from file (e.g. json or yaml).</p> <p>The object itself acts as an iterator for <code>useq.MDAEvent</code> objects:</p> <p>Attributes:</p> Name Type Description <code>metadata</code> <code>dict</code> <p>A dictionary of user metadata to be stored with the sequence.</p> <code>axis_order</code> <code>str</code> <p>The order of the axes in the sequence. Must be a permutation of <code>\"tpgcz\"</code>. The default is <code>\"tpgcz\"</code>.</p> <code>stage_positions</code> <code>tuple[Position, ...]</code> <p>The stage positions to visit. (each with <code>x</code>, <code>y</code>, <code>z</code>, <code>name</code>, and <code>sequence</code>, all of which are optional).</p> <code>grid_plan</code> <code>GridFromEdges | GridRelative | None</code> <p>The grid plan to follow. One of <code>GridFromEdges</code>, <code>GridRelative</code> or <code>None</code>.</p> <code>channels</code> <code>tuple[Channel, ...]</code> <p>The channels to acquire. see <code>Channel</code>.</p> <code>time_plan</code> <code>MultiPhaseTimePlan | TIntervalDuration | TIntervalLoops | TDurationLoops | None</code> <p>The time plan to follow. One of <code>TIntervalDuration</code>, <code>TIntervalLoops</code>, <code>TDurationLoops</code>, <code>MultiPhaseTimePlan</code>, or <code>None</code></p> <code>z_plan</code> <code>ZTopBottom | ZRangeAround | ZAboveBelow | ZRelativePositions | ZAbsolutePositions | None</code> <p>The z plan to follow. One of <code>ZTopBottom</code>, <code>ZRangeAround</code>, <code>ZAboveBelow</code>, <code>ZRelativePositions</code>, <code>ZAbsolutePositions</code>, or <code>None</code>.</p> <code>uid</code> <code>UUID</code> <p>A read-only unique identifier (uuid version 4) for the sequence. This will be generated, do not set.</p> <code>autofocus_plan</code> <code>AxesBasedAF | None</code> <p>The hardware autofocus plan to follow. One of <code>AxesBasedAF</code> or <code>None</code>.</p> <code>keep_shutter_open_across</code> <code>tuple[str, ...]</code> <p>A tuple of axes <code>str</code> across which the illumination shutter should be kept open. Resulting events will have <code>keep_shutter_open</code> set to <code>True</code> if and only if ALL axes whose indices are changing are in this tuple. For example, if <code>keep_shutter_open_across=('z',)</code>, then the shutter would be kept open between events axes {'t': 0, 'z: 0} and {'t': 0, 'z': 1}, but not between {'t': 0, 'z': 0} and {'t': 1, 'z': 0}.</p> <p>Examples:</p> <p>Create a MDASequence</p> <pre><code>&gt;&gt;&gt; from useq import MDASequence, Position, Channel, TIntervalDuration\n&gt;&gt;&gt; seq = MDASequence(\n...     axis_order=\"tpgcz\",\n...     time_plan={\"interval\": 0.1, \"loops\": 2},\n...     stage_positions=[(1, 1, 1)],\n...     grid_plan={\"rows\": 2, \"columns\": 2},\n...     z_plan={\"range\": 3, \"step\": 1},\n...     channels=[{\"config\": \"DAPI\", \"exposure\": 1}]\n... )\n</code></pre> <p>Print the sequence to visualize its structure</p> <pre><code>&gt;&gt;&gt; print(seq)\n... MDASequence(\n...     stage_positions=(Position(x=1.0, y=1.0, z=1.0, name=None),),\n...     grid_plan=GridRowsColumns(\n...         fov_width=None,\n...         fov_height=None,\n...         overlap=(0.0, 0.0),\n...         mode=&lt;OrderMode.row_wise_snake: 'row_wise_snake'&gt;,\n...         rows=2,\n...         columns=2,\n...         relative_to=&lt;RelativeTo.center: 'center'&gt;\n...     ),\n...     channels=(\n...         Channel(\n...             config='DAPI',\n...             group='Channel',\n...             exposure=1.0,\n...             do_stack=True,\n...             z_offset=0.0,\n...             acquire_every=1,\n...             camera=None\n...         ),\n...     ),\n...     time_plan=TIntervalLoops(\n...         prioritize_duration=False,\n...         interval=datetime.timedelta(microseconds=100000),\n...         loops=2\n...     ),\n...     z_plan=ZRangeAround(go_up=True, range=3.0, step=1.0)\n... )\n</code></pre> <p>Iterate over the events in the sequence</p> <pre><code>&gt;&gt;&gt; print(list(seq))\n... [\n...     MDAEvent(\n...         index=mappingproxy({'t': 0, 'p': 0, 'g': 0, 'c': 0, 'z': 0}),\n...         channel=Channel(config='DAPI'),\n...         exposure=1.0,\n...         min_start_time=0.0,\n...         x_pos=0.5,\n...         y_pos=1.5,\n...         z_pos=-0.5\n...     ),\n...     MDAEvent(\n...         index=mappingproxy({'t': 0, 'p': 0, 'g': 0, 'c': 0, 'z': 1}),\n...         channel=Channel(config='DAPI'),\n...         exposure=1.0,\n...         min_start_time=0.0,\n...         x_pos=0.5,\n...         y_pos=1.5,\n...         z_pos=0.5\n...     ),\n...     ...\n... ]\n</code></pre> <p>Print the sequence as yaml</p> <pre><code>&gt;&gt;&gt; print(seq.yaml())\n</code></pre> <pre><code>axis_order:\n   - t\n   - p\n   - g\n   - c\n   - z\nchannels:\n   - config: DAPI\n     exposure: 1.0\ngrid_plan:\n   columns: 2\n   rows: 2\nstage_positions:\n   - x: 1.0\n     y: 1.0\n     z: 1.0\ntime_plan:\n   interval: '0:00:00.100000'\n   loops: 2\nz_plan:\n   range: 3.0\n   step: 1.0\n</code></pre>"}]}