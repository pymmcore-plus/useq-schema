{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overview","text":"<p> <code>useq-schema</code> is an implementation agnostic schema for describing a sequence of events during a multi-dimensional imaging acquisition. </p> <p>The goal of this repo is to provide a specification (and some python utilities) for generating event objects that can be consumed by microscope acquisition engines. A hope is that this will encourage inter-operability between various efforts to drive automated image acquisition.</p> <p>The schema tries to remain agnostic to the specific acquisition engine (though it was designed based on the capabilities Micro-Manager). We welcome feedback from interested parties regarding limitations and/or potential extensions to the schema! Similarly, while the \"ideal\" schema will support arbitrary dimensions (i.e. more than the conventional position, time, channel, z, ...), it also hard to avoid hard-coding some assumptions about dimensionality in certain places.  Any and all feedback (even minor stuff, such as parameter naming, etc...) is welcome! Please open an issue.</p>"},{"location":"#core-schema","title":"Core Schema","text":""},{"location":"#mdaevent","title":"<code>MDAEvent</code>","text":"<p>The primary \"event\" object is <code>useq.MDAEvent</code>.  This describes a single event that a microscope should perform, including preparation of the hardware, and execution of the event (such as an image acquisition).</p> <ul> <li>For micro-manager, this   object is most similar (though not identical) to the events generated by   <code>generate-acq-sequence</code>   in the clojure acquisition engine that drives Micro-Managers multi-dimensional   acquisitions.</li> <li>For Pycro-manager, this   object is similar to an individual acquisition event   <code>dict</code>   generated by   <code>multi_d_acquisition_events</code>,   (and, <code>useq.pycromanager</code> provides a <code>to_pycromanager</code> method   that returns a dict following the pycro-manager event spec)</li> <li>your object here?...</li> </ul>"},{"location":"#mdasequence","title":"<code>MDASequence</code>","text":"<p><code>useq.MDASequence</code> represents a sequence of events \u2013 as might be generated by the multidimensional acquisition GUI in most microscope software. The Python <code>MDASequence</code> object is itself iterable, and yields <code>useq.MDAEvent</code> objects.</p> <ul> <li>For micro-manager, this   object is most similar to   <code>org.micromanager.acquisition.SequenceSettings</code>,   (generated by clicking the <code>Acquire!</code> button in the Multi-D Acquisition   GUI)</li> <li>For Pycro-manager, this   object is similar to the   <code>multi_d_acquisition_events</code>   convenience function, (and <code>useq.pycromanager</code> provides a   <code>to_pycromanager</code> method that returns a list of pycro-manager event dicts)</li> <li>your object here?...</li> </ul>"},{"location":"#executing-an-mdasequence","title":"Executing an MDASequence","text":"<p>This library is just a schema, and does not provide any built-in functionality for executing an <code>MDASequence</code>.  However, <code>pymmcore-plus</code> implements an acquisition engine that can execute an <code>MDASequence</code> object with micro-manager (via the <code>pymmcore</code> python wrapper around the C++ MMCore).  See the pymmcore-plus documentation for details. <code>napari-micromanager</code> also creates a <code>useq.MDASequence</code> object from user input and passes it to <code>pymmcore-plus</code> for execution.</p> <p>hi! </p> <p>Have you implemented an acquisition engine that can execute a <code>useq.MDASequence</code>? Let us know so we can add it here!</p>"},{"location":"#serialization-and-deserialization","title":"Serialization and Deserialization","text":"<p><code>MDASequence</code> and <code>MDAEvent</code> objects are designed to be serialized and deserialized, allowing you to define an entire multi-dimensional acquisition in human-readable YAML (or JSON) file, and then load that file into your acquisition engine.</p> <p>For example, the following file defines an experiment with:</p> <ul> <li>3 channels (<code>DAPI</code>, <code>FITC</code>, and <code>Cy5</code>), specifying exposure times in ms for each channel</li> <li>a two-phase time-lapse: 3 frames in the first phase, followed by a frame every 10 seconds for 40 minutes</li> <li>a Z-stack at each timepoint, with a range of 4 microns and a step size of 0.5 micron</li> <li>two stage positions, specifying a unique Z-stack for the second position</li> </ul> <p>Example</p> YAMLJSON my_experiment.yaml<pre><code>axis_order: tpcz\nchannels:\n  - config: Cy5\n    exposure: 50.0\n  - config: FITC\n    exposure: 100.0\n  - config: DAPI\n    acquire_every: 3\n    do_stack: false\ntime_plan:\n  phases:\n    - interval: 0:00:03\n      loops: 3\n    - duration: 0:40:00\n      interval: 0:00:10\nz_plan:\n  range: 4.0\n  step: 0.5\nstage_positions:\n  - x: 10.0\n    y: 20.0\n  - name: Cell 1\n    x: 10.0\n    y: 20.0\n    z: 50.0\n    z_plan:\n      above: 10.0\n      below: 0.0\n      step: 1.0\nmetadata:\n  some info: about my experiment\n</code></pre> my_experiment.json<pre><code>{\n  \"axis_order\": \"tpcz\",\n  \"channels\": [\n    {\n      \"config\": \"Cy5\",\n      \"exposure\": 50.0\n    },\n    {\n      \"config\": \"FITC\",\n      \"exposure\": 100.0\n    },\n    {\n      \"config\": \"DAPI\",\n      \"acquire_every\": 3,\n      \"do_stack\": false\n    }\n  ],\n  \"time_plan\": {\n    \"phases\": [\n      {\n        \"interval\": \"0:00:03\",\n        \"loops\": 3\n      },\n      {\n        \"duration\": \"0:40:00\",\n        \"interval\": \"0:00:10\"\n      }\n    ]\n  },\n  \"z_plan\": {\n    \"range\": 4.0,\n    \"step\": 0.5\n  },\n  \"stage_positions\": [\n    {\n      \"x\": 10.0,\n      \"y\": 20.0\n    },\n    {\n      \"name\": \"Cell 1\",\n      \"x\": 10.0,\n      \"y\": 20.0,\n      \"z\": 50.0,\n      \"z_plan\": {\n        \"above\": 10.0,\n        \"below\": 0.0,\n        \"step\": 1.0\n      }\n    }\n  ],\n  \"metadata\": {\n    \"some info\": \"about my experiment\"\n  }\n}\n</code></pre>"},{"location":"api/","title":"API","text":"<p>In addition to declaring a schema (which is intended to be language agnostic), <code>useq-schema</code> offers a python API for working with <code>MDASequence</code> and <code>MDAEvent</code> objects.</p>"},{"location":"api/#useq.MDASequence","title":"<code>MDASequence</code>","text":"<p>A sequence of MDA (Multi-Dimensional Acquisition) events.</p> <p>This is the core object in the <code>useq</code> library, and is used define a sequence of events to be run on a microscope. It object may be constructed manually, or from file (e.g. json or yaml).</p> <p>The object itself acts as an iterator for <code>useq.MDAEvent</code> objects:</p> <p>Attributes:</p> Name Type Description <code>metadata</code> <code>dict</code> <p>A dictionary of user metadata to be stored with the sequence.</p> <code>axis_order</code> <code>str</code> <p>The order of the axes in the sequence. Must be a permutation of <code>\"tpgcz\"</code>. The default is <code>\"tpgcz\"</code>.</p> <code>stage_positions</code> <code>tuple[Position, ...]</code> <p>The stage positions to visit. (each with <code>x</code>, <code>y</code>, <code>z</code>, <code>name</code>, and <code>sequence</code>, all of which are optional).</p> <code>grid_plan</code> <code>GridFromEdges | GridRelative | None</code> <p>The grid plan to follow. One of <code>GridFromEdges</code>, <code>GridRelative</code> or <code>None</code>.</p> <code>channels</code> <code>tuple[Channel, ...]</code> <p>The channels to acquire. see <code>Channel</code>.</p> <code>time_plan</code> <code>MultiPhaseTimePlan | TIntervalDuration | TIntervalLoops | TDurationLoops | None</code> <p>The time plan to follow. One of <code>TIntervalDuration</code>, <code>TIntervalLoops</code>, <code>TDurationLoops</code>, <code>MultiPhaseTimePlan</code>, or <code>None</code></p> <code>z_plan</code> <code>ZTopBottom | ZRangeAround | ZAboveBelow | ZRelativePositions | ZAbsolutePositions | None</code> <p>The z plan to follow. One of <code>ZTopBottom</code>, <code>ZRangeAround</code>, <code>ZAboveBelow</code>, <code>ZRelativePositions</code>, <code>ZAbsolutePositions</code>, or <code>None</code>.</p> <code>uid</code> <code>UUID</code> <p>A read-only unique identifier (uuid version 4) for the sequence. This will be generated, do not set.</p> <code>autofocus_plan</code> <code>AxesBasedAF | None</code> <p>The hardware autofocus plan to follow. One of <code>AxesBasedAF</code> or <code>None</code>.</p> <code>keep_shutter_open_across</code> <code>tuple[str, ...]</code> <p>A tuple of axes <code>str</code> across which the illumination shutter should be kept open. Resulting events will have <code>keep_shutter_open</code> set to <code>True</code> if and only if ALL axes whose indices are changing are in this tuple. For example, if <code>keep_shutter_open_across=('z',)</code>, then the shutter would be kept open between events axes {'t': 0, 'z: 0} and {'t': 0, 'z': 1}, but not between {'t': 0, 'z': 0} and {'t': 1, 'z': 0}.</p> <p>Examples:</p> <p>Create a MDASequence</p> <pre><code>&gt;&gt;&gt; from useq import MDASequence, Position, Channel, TIntervalDuration\n&gt;&gt;&gt; seq = MDASequence(\n...     axis_order=\"tpgcz\",\n...     time_plan={\"interval\": 0.1, \"loops\": 2},\n...     stage_positions=[(1, 1, 1)],\n...     grid_plan={\"rows\": 2, \"columns\": 2},\n...     z_plan={\"range\": 3, \"step\": 1},\n...     channels=[{\"config\": \"DAPI\", \"exposure\": 1}]\n... )\n</code></pre> <p>Print the sequence to visualize its structure</p> <pre><code>&gt;&gt;&gt; print(seq)\n... MDASequence(\n...     stage_positions=(Position(x=1.0, y=1.0, z=1.0, name=None),),\n...     grid_plan=GridRowsColumns(\n...         fov_width=None,\n...         fov_height=None,\n...         overlap=(0.0, 0.0),\n...         mode=&lt;OrderMode.row_wise_snake: 'row_wise_snake'&gt;,\n...         rows=2,\n...         columns=2,\n...         relative_to=&lt;RelativeTo.center: 'center'&gt;\n...     ),\n...     channels=(\n...         Channel(\n...             config='DAPI',\n...             group='Channel',\n...             exposure=1.0,\n...             do_stack=True,\n...             z_offset=0.0,\n...             acquire_every=1,\n...             camera=None\n...         ),\n...     ),\n...     time_plan=TIntervalLoops(\n...         prioritize_duration=False,\n...         interval=datetime.timedelta(microseconds=100000),\n...         loops=2\n...     ),\n...     z_plan=ZRangeAround(go_up=True, range=3.0, step=1.0)\n... )\n</code></pre> <p>Iterate over the events in the sequence</p> <pre><code>&gt;&gt;&gt; print(list(seq))\n... [\n...     MDAEvent(\n...         index=mappingproxy({'t': 0, 'p': 0, 'g': 0, 'c': 0, 'z': 0}),\n...         channel=Channel(config='DAPI'),\n...         exposure=1.0,\n...         min_start_time=0.0,\n...         x_pos=0.5,\n...         y_pos=1.5,\n...         z_pos=-0.5\n...     ),\n...     MDAEvent(\n...         index=mappingproxy({'t': 0, 'p': 0, 'g': 0, 'c': 0, 'z': 1}),\n...         channel=Channel(config='DAPI'),\n...         exposure=1.0,\n...         min_start_time=0.0,\n...         x_pos=0.5,\n...         y_pos=1.5,\n...         z_pos=0.5\n...     ),\n...     ...\n... ]\n</code></pre> <p>Print the sequence as yaml</p> <pre><code>&gt;&gt;&gt; print(seq.yaml())\n</code></pre> <pre><code>axis_order:\n   - t\n   - p\n   - g\n   - c\n   - z\nchannels:\n   - config: DAPI\n     exposure: 1.0\ngrid_plan:\n   columns: 2\n   rows: 2\nstage_positions:\n   - x: 1.0\n     y: 1.0\n     z: 1.0\ntime_plan:\n   interval: '0:00:00.100000'\n   loops: 2\nz_plan:\n   range: 3.0\n   step: 1.0\n</code></pre>"},{"location":"api/#useq.MDASequence.shape","title":"<code>shape: tuple[int, ...]</code>  <code>property</code>","text":"<p>Return the shape of this sequence.</p> <p>Note</p> <p>This doesn't account for jagged arrays, like channels that exclude z stacks or skip timepoints.</p>"},{"location":"api/#useq.MDASequence.sizes","title":"<code>sizes: Mapping[str, int]</code>  <code>property</code>","text":"<p>Mapping of axis name to size of that axis.</p>"},{"location":"api/#useq.MDASequence.uid","title":"<code>uid: UUID</code>  <code>property</code>","text":"<p>A unique identifier for this sequence.</p>"},{"location":"api/#useq.MDASequence.used_axes","title":"<code>used_axes: str</code>  <code>property</code>","text":"<p>Single letter string of axes used in this sequence, e.g. <code>ztc</code>.</p>"},{"location":"api/#useq.MDASequence.__eq__","title":"<code>__eq__(other: Any) -&gt; bool</code>","text":"<p>Return <code>True</code> if two <code>MDASequences</code> are equal (uid is excluded).</p>"},{"location":"api/#useq.MDASequence.__iter__","title":"<code>__iter__() -&gt; Iterator[MDAEvent]</code>","text":"<p>Same as <code>iter_events</code>. Supports <code>for event in sequence: ...</code> syntax.</p>"},{"location":"api/#useq.MDASequence.estimate_duration","title":"<code>estimate_duration() -&gt; TimeEstimate</code>","text":"<p>Estimate duration and other timing issues of an MDASequence.</p> <p>Notable mis-estimations may include: - when the time interval is shorter than the time it takes to acquire the data and any of the channels have <code>acquire_every</code> &gt; 1 - when channel exposure times are omitted. In this case, we assume 1ms exposure.</p> <p>Returns:</p> Type Description <code>TimeEstimate</code> <p>A named 3-tuple with the following fields: - total_duration: float     Estimated total duration of the experiment, in seconds. - per_t_duration: float     Estimated duration of a single timepoint, in seconds. - time_interval_exceeded: bool     Whether the time interval between timepoints is shorter than the time it     takes to acquire the data</p>"},{"location":"api/#useq.MDASequence.iter_axis","title":"<code>iter_axis(axis: str) -&gt; Iterator[Channel | float | PositionBase]</code>","text":"<p>Iterate over the positions or items of a given axis.</p>"},{"location":"api/#useq.MDASequence.iter_events","title":"<code>iter_events() -&gt; Iterator[MDAEvent]</code>","text":"<p>Iterate over all events in the MDA sequence.</p> <p>See source of <code>iter_sequence</code> for details on how events are constructed and yielded.</p> <p>Yields:</p> Type Description <code>MDAEvent</code> <p>Each event in the MDA sequence.</p>"},{"location":"api/#useq._mda_sequence.iter_sequence","title":"<code>iter_sequence(sequence)</code>","text":"<p>Iterate over all events in the MDA sequence.'.</p> <p>Note</p> <p>This method will usually be used via <code>useq.MDASequence.iter_events</code>, or by simply iterating over the sequence.</p> <p>This does the job of iterating over all the frames in the MDA sequence, handling the logic of merging all z plans in channels and stage positions defined in the plans for each axis.</p> <p>The is the most \"logic heavy\" part of <code>useq-schema</code> (the rest of which is almost entirely declarative).  This iterator is useful for consuming <code>MDASequence</code> objects in a python runtime, but it isn't considered a \"core\" part of the schema.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>MDASequence</code> <p>The sequence to iterate over.</p> required <p>Yields:</p> Type Description <code>MDAEvent</code> <p>Each event in the MDA sequence.</p> Source code in <code>src/useq/_iter_sequence.py</code> <pre><code>def iter_sequence(sequence: MDASequence) -&gt; Iterator[MDAEvent]:\n    \"\"\"Iterate over all events in the MDA sequence.'.\n\n    !!! note\n        This method will usually be used via [`useq.MDASequence.iter_events`][], or by\n        simply iterating over the sequence.\n\n    This does the job of iterating over all the frames in the MDA sequence,\n    handling the logic of merging all z plans in channels and stage positions\n    defined in the plans for each axis.\n\n    The is the most \"logic heavy\" part of `useq-schema` (the rest of which is\n    almost entirely declarative).  This iterator is useful for consuming `MDASequence`\n    objects in a python runtime, but it isn't considered a \"core\" part of the schema.\n\n    Parameters\n    ----------\n    sequence : MDASequence\n        The sequence to iterate over.\n\n    Yields\n    ------\n    MDAEvent\n        Each event in the MDA sequence.\n    \"\"\"\n    if not (keep_shutter_open_axes := sequence.keep_shutter_open_across):\n        yield from _iter_sequence(sequence)\n        return\n\n    it = _iter_sequence(sequence)\n    if (this_e := next(it, None)) is None:  # pragma: no cover\n        return\n\n    for next_e in it:\n        # set `keep_shutter_open` to `True` if and only if ALL axes whose index\n        # changes betwee this_event and next_event are in `keep_shutter_open_axes`\n        if all(\n            axis in keep_shutter_open_axes\n            for axis, idx in this_e.index.items()\n            if idx != next_e.index[axis]\n        ):\n            this_e = this_e.model_copy(update={\"keep_shutter_open\": True})\n        yield this_e\n        this_e = next_e\n    yield this_e\n</code></pre>"},{"location":"v2-migration/","title":"v2 Migration Guide","text":""},{"location":"v2-migration/#overview","title":"Overview","text":"<p>The v2 version of <code>useq-schema</code> represents a fundamental architectural redesign that generalizes the multi-dimensional axis iteration pattern to support arbitrary dimensions while preserving the complex event building, nesting, and skipping capabilities of the original implementation. This document explains the new features, how to use and extend them, and the breaking changes from v1.</p>"},{"location":"v2-migration/#key-architectural-changes","title":"Key Architectural Changes","text":""},{"location":"v2-migration/#from-fixed-axes-to-extensible-axis-system","title":"From Fixed Axes to Extensible Axis System","text":"<p>v1 Approach: Hard-coded support for specific axes (<code>time</code>, <code>position</code>, <code>grid</code>, <code>channel</code>, <code>z</code>) with bespoke iteration logic in <code>_iter_sequence.py</code>.</p> <p>v2 Approach: Generic, protocol-based system where any object implementing <code>AxisIterable</code> can participate in multi-dimensional iteration.</p>"},{"location":"v2-migration/#core-concepts","title":"Core Concepts","text":""},{"location":"v2-migration/#1-axisiterablev-protocol","title":"1. <code>AxisIterable[V]</code> Protocol","text":"<p>The foundation of v2 is the <code>AxisIterable</code> protocol, which defines how any axis should behave.  In short, an <code>AxisIterable</code> is an object that yields values (of any type), has an associated <code>axis_key</code>, and can contribute to event building and skipping logic.</p> <pre><code>from pydantic import BaseModel, Field\nfrom typing import Generic, Iterator, Mapping, TypeVar\nfrom abc import abstractmethod\n\nV = TypeVar(\"V\")\n\nclass AxisIterable(BaseModel, Generic[V]):\n    axis_key: str  # Unique identifier for this axis\n\n    @abstractmethod\n    def __iter__(self) -&gt; Iterator[V]:\n        \"\"\"Iterate over axis values\"\"\"\n\n    def should_skip(self, prefix: AxesIndex) -&gt; bool:\n        \"\"\"Return True to skip this combination\"\"\"\n        return False\n\n    def contribute_to_mda_event(\n        self, value: V, index: Mapping[str, int]\n    ) -&gt; MDAEvent.Kwargs:\n        \"\"\"Contribute data to the event being built\"\"\"\n        return {}\n</code></pre>"},{"location":"v2-migration/#2-simplevalueaxisv-basic-implementation","title":"2. <code>SimpleValueAxis[V]</code> - Basic Implementation","text":"<p>For simple cases where you just want to iterate over a list of values:</p> <pre><code>class SimpleValueAxis(AxisIterable[V]):\n    values: list[V] = Field(default_factory=list)\n\n    def __iter__(self) -&gt; Iterator[V | MultiAxisSequence]:\n        yield from self.values\n</code></pre> <pre><code>axis = SimpleValueAxis(axis_key=\"z\", values=[0, 1, 2, 3, 4])\nfor z in axis:\n    print(z)  # Outputs 0, 1, 2, 3, 4\n</code></pre>"},{"location":"v2-migration/#3-multiaxissequenceeventt-the-new-sequence-container","title":"3. <code>MultiAxisSequence[EventT]</code> - The New Sequence Container","text":"<p>Replaces the old <code>MDASequence</code> as the core container, but with generic event support.  A <code>MultiAxisSequence</code> holds any number of <code>AxisIterable</code> objects, defines their order, and manages how the values from each axis get merged into an event.</p> <pre><code>EventT = TypeVar(\"EventT\")\n\nclass MultiAxisSequence(BaseModel, Generic[EventT]):\n    axes: tuple[AxisIterable, ...] = ()\n    axis_order: Optional[tuple[str, ...]] = None\n\n    value: Any = None  # Used when this sequence is nested\n    event_builder: Optional[EventBuilder[EventT]] = None\n    transforms: tuple[EventTransform, ...] = ()\n</code></pre>"},{"location":"v2-migration/#4-mdasequence","title":"4. <code>MDASequence</code>","text":"<p>There is still an <code>MDASequence</code> class in v2, which is a subclass of <code>MultiAxisSequence</code> specialized for building <code>MDAEvent</code> objects.</p> <pre><code>from useq.v2 import MDAEvent\n\nclass MDASequence(MultiAxisSequence[MDAEvent]):\n    ...\n</code></pre> <p>In other words, <code>MultiAxisSequence</code> is a generic iterator over multiple axes that can build any type of event, while <code>MDASequence</code> is a specific implementation that builds <code>MDAEvent</code> objects (just like v1).</p>"},{"location":"v2-migration/#new-features","title":"New Features","text":""},{"location":"v2-migration/#1-arbitrary-custom-axes","title":"1. Arbitrary Custom Axes","text":"<p>You can now define completely custom axes for any dimension:</p> <pre><code>from useq import v2\n\n# Custom axis for laser power\nclass LaserPowerAxis(v2.SimpleValueAxis[float]):\n    axis_key: str = \"laser_power\"\n\n    def contribute_to_mda_event(self, value: float, index: Mapping[str, int]) -&gt; v2.MDAEvent.Kwargs:\n        return {\"metadata\": {\"laser_power\": value}}\n\n# Custom axis for temperature\nclass TemperatureAxis(v2.AxisIterable[float]):\n    axis_key: str = \"temperature\"\n    min_temp: float\n    max_temp: float\n    step: float\n\n    def __iter__(self) -&gt; Iterator[float]:\n        temp = self.min_temp\n        while temp &lt;= self.max_temp:\n            yield temp\n            temp += self.step\n\n    def contribute_to_mda_event(self, value: float, index: Mapping[str, int]) -&gt; v2.MDAEvent.Kwargs:\n        return {\"metadata\": {\"temperature\": value}}\n</code></pre>"},{"location":"v2-migration/#2-conditional-skipping-with-should_skip","title":"2. Conditional Skipping with <code>should_skip</code>","text":"<p><code>should_skip</code> method on any axis allows context-aware skipping of specific combinations.  It receives an <code>AxesIndex</code>, which contains information on the exact value and index being yielded by each axis in this iteration step.</p> <pre><code>class FilteredChannelAxis(v2.SimpleValueAxis[v2.Channel]):\n    def should_skip(self, prefix: v2.AxesIndex) -&gt; bool:\n        # Skip FITC channel for even numbered Z positions\n        z_idx = prefix.get(\"z\", (None, None, None))[0]\n        current_channel = prefix.get(\"c\", (None, None, None))[1]\n\n        if z_idx is not None and z_idx % 2 == 0:\n            return current_channel.config == \"FITC\"\n        return False\n</code></pre>"},{"location":"v2-migration/#3-hierarchical-nested-sequences","title":"3. Hierarchical Nested Sequences","text":"<p>The new system supports arbitrarily nested sequences that can override or extend parent axes.  A <code>MultiAxisSequence</code> itself can have a <code>value</code>, allowing it to be used as a yielded value from a parent axis.</p> <p>In the following example, we define a sub-sequence for a specific position that adds a temperature axis and overrides the Z plan defined in the parent sequence:</p> <pre><code>from useq import v2\n# Position with custom sub-sequence (uses MDASequence, which StagePositions accepts)\nsub_sequence = v2.MDASequence(\n    value=v2.Position(x=10, y=20),  # The value represents this position\n    axes=(\n        # Add temperature dimension\n        v2.SimpleValueAxis(axis_key=\"temperature\", values=[20, 25, 30]),\n        # Override parent Z plan\n        v2.ZRangeAround(range=2, step=0.5),\n    ),\n    axis_order=(\"temperature\", \"z\")\n)\n\nmain_sequence = v2.MDASequence(\n    axes=(\n        v2.TIntervalLoops(interval=1.0, loops=5),\n        v2.StagePositions(values=[sub_sequence, v2.Position(x=0, y=0)]),\n        v2.ZRangeAround(range=4, step=1.0),  # This gets overridden for the first position\n    )\n)\n</code></pre>"},{"location":"v2-migration/#4-event-transform-pipeline","title":"4. Event Transform Pipeline","text":"<p>Transforms allow you to modify events after they are built but before they are yielded. This replaces the old hardcoded event modification logic with a flexible, composable pipeline:</p> <pre><code>from useq.v2 import KeepShutterOpenTransform, EventTransform\n\nclass CustomTransform(EventTransform[MDAEvent]):\n    def __call__(\n        self,\n        event: MDAEvent,\n        *,\n        prev_event: MDAEvent | None,\n        make_next_event: Callable[[], MDAEvent | None],\n    ) -&gt; Iterable[MDAEvent]:\n        # Modify event\n        if event.index.get(\"c\") == 0:  # First channel\n            event = event.model_copy(update={\"exposure\": 100})\n\n        # Can return multiple events, no events, or modify the event\n        return [event]\n\nseq = v2.MDASequence(\n    channels=[\"DAPI\", \"FITC\"],  # Using legacy API for brevity\n    transforms=(CustomTransform(), KeepShutterOpenTransform((\"z\",)))\n)\n</code></pre>"},{"location":"v2-migration/#41-built-in-transforms","title":"4.1 Built-in Transforms","text":"<p>v2 provides several built-in transforms that replicate v1 behavior. Note: transforms are currently available from <code>useq.v2._transformers</code>:</p> <pre><code>from useq.v2 import (\n    AutoFocusTransform,\n    KeepShutterOpenTransform,\n    ResetEventTimerTransform,\n)\n\n# Shutter management - keeps shutter open across specified axes\nKeepShutterOpenTransform((\"z\", \"c\"))\n\n# Event timing - marks first frame of each timepoint for timer reset\nResetEventTimerTransform()\n</code></pre>"},{"location":"v2-migration/#42-non-imaging-events-with-transforms","title":"4.2 Non-Imaging Events with Transforms","text":"<p>A key innovation in v2 is the ability to use transforms to insert non-imaging events that don't contribute to the sequence shape. This addresses GitHub issue #41 for use cases like laser measurements and Raman spectroscopy:</p> <pre><code>class LaserMeasurementTransform(EventTransform[MDAEvent]):\n    \"\"\"Insert laser measurement events after BF z-stacks.\"\"\"\n\n    def __call__(\n        self,\n        event: MDAEvent,\n        *,\n        prev_event: MDAEvent | None,\n        make_next_event: Callable[[], MDAEvent | None],\n    ) -&gt; Iterable[MDAEvent]:\n        # Yield the original imaging event\n        yield event\n\n        # If this is the last event in a BF z-stack, add laser measurements\n        if (event.channel and event.channel.config == \"BF\" and \n            self._is_last_z_event(event, make_next_event)):\n\n            # Insert 5 laser measurement events at different points\n            for i, (x_offset, y_offset) in enumerate([(0, 0), (10, 0), (0, 10), (-10, 0), (0, -10)]):\n                laser_event = MDAEvent(\n                    index={\"t\": event.index.get(\"t\", 0), \"laser\": i},\n                    x_pos=(event.x_pos or 0) + x_offset,\n                    y_pos=(event.y_pos or 0) + y_offset,\n                    action=CustomAction(type=\"laser_measurement\", data={\"laser_power\": 75})\n                )\n                yield laser_event\n\n    def _is_last_z_event(self, event: MDAEvent, make_next_event: Callable) -&gt; bool:\n        next_event = make_next_event()\n        return (next_event is None or \n                next_event.channel is None or \n                next_event.channel.config != \"BF\")\n\n# Usage for the GitHub issue #41 use case:\n# 1. Collect BF z-stack \u2192 2. Laser measurements \u2192 3. GFP z-stack\nseq = v2.MDASequence(\n    channels=[\"BF\", \"GFP\"],  \n    z_plan=v2.ZRangeAround(range=2, step=0.5),\n    transforms=(LaserMeasurementTransform(),)\n)\n\n# This generates:\n# - BF z-stack events (contribute to shape)\n# - 5 laser measurement events (inserted by transform, don't affect shape)\n# - GFP z-stack events (contribute to shape)\n</code></pre>"},{"location":"v2-migration/#5-pluggable-event-builders","title":"5. Pluggable Event Builders","text":"<p>Customize how raw axis data gets converted into events:</p> <pre><code>class MyCustomEvent: ...\n\nclass CustomEventBuilder(v2.EventBuilder[MyCustomEvent]):\n    def __call__(\n        self, axes_index: v2.AxesIndex, context: tuple[v2.MultiAxisSequence, ...]\n    ) -&gt; MyCustomEvent:\n        # Build your custom event type\n        return MyCustomEvent(...)\n\nseq = v2.MultiAxisSequence(\n    axes=(),\n    event_builder=CustomEventBuilder()\n)\n</code></pre>"},{"location":"v2-migration/#6-infinite-axes-support","title":"6. Infinite Axes Support","text":"<p>Unlike v1, v2 supports infinite sequences:</p> <pre><code>class InfiniteTimeAxis(v2.AxisIterable[float]):\n    axis_key: str = \"t\"\n    interval: float = 1.0\n\n    def __iter__(self) -&gt; Iterator[float]:\n        time = 0.0\n        while True:\n            yield time\n            time += self.interval\n</code></pre>"},{"location":"v2-migration/#migration-from-v1-to-v2","title":"Migration from v1 to v2","text":""},{"location":"v2-migration/#backward-compatibility","title":"Backward Compatibility","text":"<p>v2 <code>MDASequence</code> accepts the same constructor parameters as v1 through automatic conversion:</p> <pre><code># This v1 style still works\nseq = v2.MDASequence(\n    time_plan={\"interval\": 1.0, \"loops\": 5},\n    z_plan={\"range\": 4, \"step\": 1},\n    channels=[\"DAPI\", \"FITC\"],\n    stage_positions=[(10, 20, 5)],\n)\n\n# Internally converted to:\nseq2 = v2.MDASequence(\n    axes=(\n        v2.TIntervalLoops(interval=1.0, loops=5),\n        v2.StagePositions(values=[v2.Position(x=10, y=20, z=5)]),\n        v2.ChannelsPlan(values=[v2.Channel(config=\"DAPI\"), v2.Channel(config=\"FITC\")]),\n        v2.ZRangeAround(range=4, step=1),\n    ),\n)\n\nassert list(seq) == list(seq2)\n</code></pre>"},{"location":"v2-migration/#breaking-changes","title":"Breaking Changes","text":""},{"location":"v2-migration/#1-event-building-architecture","title":"1. Event Building Architecture","text":"<p>v1: Monolithic <code>_iter_sequence</code> function with hardcoded event building logic.</p> <p>v2: Separation of concerns:</p> <ul> <li>Axis iteration handled by <code>iterate_multi_dim_sequence</code></li> <li>Event building handled by <code>EventBuilder</code></li> <li>Event modification handled by <code>EventTransform</code> pipeline</li> </ul>"},{"location":"v2-migration/#2-shape-and-sizes-properties","title":"2. Shape and Sizes Properties","text":"<pre><code>from useq import MDASequence\nfrom useq import v2\n\n# v1\nseq = MDASequence()\nseq.shape  # Returns tuple of sizes\nseq.sizes  # Returns mapping of axis -&gt; size\n\n# v2 - DEPRECATED\nseq2 = v2.MDASequence()\nseq2.shape  # Deprecated - raises FutureWarning\nseq2.sizes  # Deprecated - raises FutureWarning\n\n# v2 - New approach\n[len(axis) for axis in seq2.axes]  # Get size per axis\nseq2.is_finite()  # Check if sequence is finite\n</code></pre>"},{"location":"v2-migration/#3-axis-access","title":"3. Axis Access","text":"<pre><code># v1\nseq.time_plan\nseq.z_plan\nseq.channels\nseq.stage_positions\nseq.grid_plan\n\n# v2 - Legacy properties still work but deprecated\nseq2.time_plan  # Returns the time axis or None\nseq2.z_plan     # Returns the z axis or None\n\n# v2 - New approach\ntime_axis = next((ax for ax in seq2.axes if ax.axis_key == \"t\"), None)\nz_axis = next((ax for ax in seq2.axes if ax.axis_key == \"z\"), None)\n\n# each of which have convenience methods:\ntime_axis = seq2.time_plan\nz_axis = seq2.z_plan\n</code></pre>"},{"location":"v2-migration/#4-custom-skip-logic","title":"4. Custom Skip Logic","text":"<p>v1: Hardcoded in <code>_should_skip</code> function within <code>_iter_sequence.py</code></p> <p>v2: Implemented per-axis via <code>should_skip</code> method:</p> <pre><code>class CustomZAxis(v2.ZRangeAround):\n    def should_skip(self, prefix: AxesIndex) -&gt; bool:\n        # Custom logic here\n        return super().should_skip(prefix)\n</code></pre>"},{"location":"v2-migration/#z-z-plans-yield-positions-not-floats","title":"Z. Z-Plans yield Positions, not floats","text":"<p>v1: Z plans yielded floats representing Z positions.</p> <p>v2: Z plans yield <code>Position</code> objects that (usually) include only z coordinates:</p>"},{"location":"v2-migration/#built-in-axes-in-v2","title":"Built-in Axes in v2","text":"<p>All the original v1 plans are now <code>AxisIterable</code> implementations:</p>"},{"location":"v2-migration/#time-axes","title":"Time Axes","text":"<ul> <li><code>TIntervalLoops</code></li> <li><code>TIntervalDuration</code></li> <li><code>TDurationLoops</code></li> <li><code>MultiPhaseTimePlan</code></li> </ul>"},{"location":"v2-migration/#z-axes","title":"Z Axes","text":"<ul> <li><code>ZRangeAround</code></li> <li><code>ZTopBottom</code></li> <li><code>ZAboveBelow</code></li> <li><code>ZAbsolutePositions</code></li> <li><code>ZRelativePositions</code></li> </ul>"},{"location":"v2-migration/#channel-axes","title":"Channel Axes","text":"<ul> <li><code>ChannelsPlan</code> (wraps list of <code>Channel</code> objects)</li> </ul>"},{"location":"v2-migration/#position-axes","title":"Position Axes","text":"<ul> <li><code>StagePositions</code> (wraps list of <code>Position</code> objects)</li> </ul>"},{"location":"v2-migration/#grid-axes","title":"Grid Axes","text":"<ul> <li><code>GridRowsColumns</code></li> <li><code>GridFromEdges</code></li> <li><code>GridWidthHeight</code></li> <li><code>RandomPoints</code></li> </ul>"},{"location":"v2-migration/#extension-examples","title":"Extension Examples","text":""},{"location":"v2-migration/#creating-a-custom-scientific-axis","title":"Creating a Custom Scientific Axis","text":"<pre><code>class PHAxis(v2.AxisIterable[float]):\n    \"\"\"Axis for pH titration experiments.\"\"\"\n    axis_key: str = \"ph\"\n    start_ph: float = 6.0\n    end_ph: float = 8.0\n    steps: int = 10\n\n    def __iter__(self) -&gt; Iterator[float]:\n        step_size = (self.end_ph - self.start_ph) / (self.steps - 1)\n        for i in range(self.steps):\n            yield self.start_ph + i * step_size\n\n    def contribute_to_mda_event(self, value: float, index: Mapping[str, int]) -&gt; MDAEvent.Kwargs:\n        return {\n            \"metadata\": {\"ph\": value},\n            \"properties\": [(\"pH_Controller\", \"target_ph\", value)]\n        }\n\n    def should_skip(self, prefix: AxesIndex) -&gt; bool:\n        # Skip pH 7.5+ for channel index &gt; 2\n        channel_idx = prefix.get(\"c\", (None, None, None))[0]\n        ph_value = prefix.get(\"ph\", (None, None, None))[1]\n        return channel_idx is not None and channel_idx &gt; 2 and ph_value &gt;= 7.5\n</code></pre>"},{"location":"v2-migration/#complex-nested-workflow","title":"Complex Nested Workflow","text":"<pre><code>from useq import v2\n\n# Different regions with different imaging parameters\nregion1 = v2.MDASequence(\n    value=v2.Position(x=0, y=0, name=\"Region1\"),\n    axes=(\n        v2.ZRangeAround(range=10, step=0.2),  # High-res Z\n        v2.ChannelsPlan(values=[\"DAPI\", \"FITC\", \"Cy3\"]),  # 3 channels\n    )\n)\n\nregion2 = v2.MDASequence(\n    value=v2.Position(x=100, y=100, name=\"Region2\"),\n    axes=(\n        v2.ZRangeAround(range=20, step=0.5),  # Lower-res Z\n        v2.ChannelsPlan(values=[\"DAPI\", \"Cy5\"]),  # Only 2 channels\n        PHAxis(start_ph=6.5, end_ph=7.5, steps=5),  # pH titration\n    )\n)\n\nclass CustomTransform:\n    def __call__(\n        self,\n        event: v2.MDAEvent,\n        *,\n        prev_event: v2.MDAEvent | None,\n        make_next_event: Callable[[], v2.MDAEvent | None],\n    ) -&gt; Iterable[v2.MDAEvent]:\n        # possibly modify event... based on conditions\n        yield event\n\nmain_seq = v2.MDASequence(\n    axes=(\n        v2.TIntervalLoops(interval=60, loops=10),  # Every minute for 10 minutes\n        v2.StagePositions(values=[region1, region2]),\n    ),\n    transforms=(\n        CustomTransform(),\n        v2.KeepShutterOpenTransform((\"z\", \"c\")),  # Keep shutter open for Z and C\n    )\n)\n</code></pre>"},{"location":"v2-migration/#performance-and-design-benefits","title":"Performance and Design Benefits","text":""},{"location":"v2-migration/#separation-of-concerns","title":"Separation of Concerns","text":"<ul> <li>Axis logic: Isolated in individual <code>AxisIterable</code> implementations</li> <li>Event building: Centralized in <code>EventBuilder</code></li> <li>Event modification: Composable <code>EventTransform</code> pipeline</li> </ul>"},{"location":"v2-migration/#extensibility","title":"Extensibility","text":"<ul> <li>Add new dimensions without modifying core code</li> <li>Custom skip logic per axis</li> <li>Pluggable event builders for different event types</li> <li>Composable transform pipeline</li> </ul>"},{"location":"v2-migration/#type-safety","title":"Type Safety","text":"<ul> <li>Generic types ensure type safety across the pipeline</li> <li>Protocol-based design enables duck typing</li> <li>Clear interfaces for each component</li> </ul>"},{"location":"v2-migration/#maintainability","title":"Maintainability","text":"<ul> <li>Individual axis implementations are easier to test and debug</li> <li>Transform pipeline is easier to reason about than monolithic logic</li> <li>Clear separation between axis iteration and event building</li> </ul>"},{"location":"v2-migration/#summary","title":"Summary","text":"<p>useq-schema v2 transforms the library from a fixed-axis system to a fully extensible, protocol-based architecture that supports:</p> <ul> <li>Arbitrary custom axes with their own iteration and contribution logic</li> <li>Conditional skipping per axis with full context awareness  </li> <li>Hierarchical nesting with axis override capabilities</li> <li>Composable transforms for event modification</li> <li>Pluggable event builders for different event types</li> <li>Type-safe extensibility through generic protocols</li> </ul> <p>While maintaining full backward compatibility with v1 API patterns, v2 opens up useq-schema for complex, multi-dimensional experimental workflows that were impossible to express in the original architecture.</p>"},{"location":"schema/axes/","title":"Axes","text":"<p>The following objects may be used to describe iteration over specific types of dimensions.</p>"},{"location":"schema/axes/#useq.Position","title":"<code>Position = AbsolutePosition</code>  <code>module-attribute</code>","text":""},{"location":"schema/axes/#useq.Channel","title":"<code>Channel</code>","text":"<p>Define an acquisition channel.</p> <p>Attributes:</p> Name Type Description <code>config</code> <code>str</code> <p>Name of the configuration to use for this channel, (e.g. <code>\"488nm\"</code>, <code>\"DAPI\"</code>, <code>\"FITC\"</code>).</p> <code>group</code> <code>str</code> <p>Optional name of the group to which this channel belongs. By default, <code>\"Channel\"</code>.</p> <code>exposure</code> <code>float | None</code> <p>Exposure time in milliseconds. Must be positive.  If not provided, implies use current exposure time. By default, <code>None</code>.</p> <code>do_stack</code> <code>bool</code> <p>If <code>True</code>, instructs engine to include this channel in any Z stacks being acquired. By default, <code>True</code>.</p> <code>z_offset</code> <code>float</code> <p>Relative Z offset from current position, in microns. By default, <code>0</code>.</p> <code>acquire_every</code> <code>int</code> <p>Acquire every Nth frame (if acquiring a time series). By default, <code>1</code>.</p> <code>camera</code> <code>str | None</code> <p>Name of the camera to use for this channel. If not provided, implies use current camera. By default, <code>None</code>.</p>"},{"location":"schema/axes/#time-plans","title":"Time Plans","text":"<p>Ways to describe a temporal acquisition sequence.</p>"},{"location":"schema/axes/#useq.TIntervalDuration","title":"<code>TIntervalDuration</code>","text":"<p>Define temporal sequence using interval and duration.</p> <p>Attributes:</p> Name Type Description <code>interval</code> <code>str | timedelta</code> <p>Time between frames. Scalars are interpreted as seconds. Strings are parsed according to ISO 8601.</p> <code>duration</code> <code>str | timedelta</code> <p>Total duration of sequence.</p> <code>prioritize_duration</code> <code>bool</code> <p>If <code>True</code>, instructs engine to prioritize duration over number of frames in case of conflict. By default, <code>True</code>.</p>"},{"location":"schema/axes/#useq.TIntervalLoops","title":"<code>TIntervalLoops</code>","text":"<p>Define temporal sequence using interval and number of loops.</p> <p>Attributes:</p> Name Type Description <code>interval</code> <code>str | timedelta | float</code> <p>Time between frames. Scalars are interpreted as seconds. Strings are parsed according to ISO 8601.</p> <code>loops</code> <code>int</code> <p>Number of frames.</p> <code>prioritize_duration</code> <code>bool</code> <p>If <code>True</code>, instructs engine to prioritize duration over number of frames in case of conflict. By default, <code>False</code>.</p>"},{"location":"schema/axes/#useq.TDurationLoops","title":"<code>TDurationLoops</code>","text":"<p>Define temporal sequence using duration and number of loops.</p> <p>Attributes:</p> Name Type Description <code>duration</code> <code>str | timedelta</code> <p>Total duration of sequence. Scalars are interpreted as seconds. Strings are parsed according to ISO 8601.</p> <code>loops</code> <code>int</code> <p>Number of frames.</p> <code>prioritize_duration</code> <code>bool</code> <p>If <code>True</code>, instructs engine to prioritize duration over number of frames in case of conflict. By default, <code>False</code>.</p>"},{"location":"schema/axes/#useq.TIntervalDuration","title":"<code>TIntervalDuration</code>","text":"<p>Define temporal sequence using interval and duration.</p> <p>Attributes:</p> Name Type Description <code>interval</code> <code>str | timedelta</code> <p>Time between frames. Scalars are interpreted as seconds. Strings are parsed according to ISO 8601.</p> <code>duration</code> <code>str | timedelta</code> <p>Total duration of sequence.</p> <code>prioritize_duration</code> <code>bool</code> <p>If <code>True</code>, instructs engine to prioritize duration over number of frames in case of conflict. By default, <code>True</code>.</p>"},{"location":"schema/axes/#useq.MultiPhaseTimePlan","title":"<code>MultiPhaseTimePlan</code>","text":"<p>Time sequence composed of multiple phases.</p> <p>Attributes:</p> Name Type Description <code>phases</code> <code>Sequence[TIntervalDuration | TIntervalLoops | TDurationLoops]</code> <p>Sequence of time plans.</p>"},{"location":"schema/axes/#z-plans","title":"Z Plans","text":"<p>Ways to describe a z-stack acquisition sequence.</p>"},{"location":"schema/axes/#useq.ZTopBottom","title":"<code>ZTopBottom</code>","text":"<p>Define Z using absolute top &amp; bottom positions.</p> <p>Note that <code>bottom</code> will always be visited, regardless of <code>go_up</code>, while <code>top</code> will always be encompassed by the range, but may not be precisely visited if the step size does not divide evenly into the range.</p> <p>Attributes:</p> Name Type Description <code>top</code> <code>float</code> <p>Top position in microns (inclusive).</p> <code>bottom</code> <code>float</code> <p>Bottom position in microns (inclusive).</p> <code>step</code> <code>float</code> <p>Step size in microns.</p> <code>go_up</code> <code>bool</code> <p>If <code>True</code>, instructs engine to start at bottom and move towards top. By default, <code>True</code>.</p>"},{"location":"schema/axes/#useq.ZAboveBelow","title":"<code>ZAboveBelow</code>","text":"<p>Define Z as asymmetric range above and below some reference position.</p> <p>Note that <code>below</code> will always be visited, regardless of <code>go_up</code>, while <code>above</code> will always be encompassed by the range, but may not be precisely visited if the step size does not divide evenly into the range.</p> <p>Attributes:</p> Name Type Description <code>above</code> <code>float</code> <p>Range above reference position in microns (inclusive).</p> <code>below</code> <code>float</code> <p>Range below reference position in microns (inclusive).</p> <code>step</code> <code>float</code> <p>Step size in microns.</p> <code>go_up</code> <code>bool</code> <p>If <code>True</code>, instructs engine to start at bottom and move towards top. By default, <code>True</code>.</p>"},{"location":"schema/axes/#useq.ZAbsolutePositions","title":"<code>ZAbsolutePositions</code>","text":"<p>Define Z as a list of absolute positions.</p> <p>Attributes:</p> Name Type Description <code>absolute</code> <code>list[float]</code> <p>List of absolute z positions.</p> <code>go_up</code> <code>bool</code> <p>If <code>True</code> (the default), visits points in the order provided, otherwise in reverse.</p>"},{"location":"schema/axes/#useq.ZRangeAround","title":"<code>ZRangeAround</code>","text":"<p>Define Z as a symmetric range around some reference position.</p> <p>Note that <code>-range / 2</code> will always be visited, regardless of <code>go_up</code>, while <code>+range / 2</code> will always be encompassed by the range, but may not be precisely visited if the step size does not divide evenly into the range.</p> <p>Attributes:</p> Name Type Description <code>range</code> <code>float</code> <p>Range in microns (inclusive). For example, a range of 4 with a step size of 1 would visit [-2, -1, 0, 1, 2].</p> <code>step</code> <code>float</code> <p>Step size in microns.</p> <code>go_up</code> <code>bool</code> <p>If <code>True</code>, instructs engine to start at bottom and move towards top. By default, <code>True</code>.</p>"},{"location":"schema/axes/#useq.ZRelativePositions","title":"<code>ZRelativePositions</code>","text":"<p>Define Z as a list of positions relative to some reference.</p> <p>Typically, the \"reference\" will be whatever the current Z position is at the start of the sequence.</p> <p>Attributes:</p> Name Type Description <code>relative</code> <code>list[float]</code> <p>List of relative z positions.</p> <code>go_up</code> <code>bool</code> <p>If <code>True</code> (the default), visits points in the order provided, otherwise in reverse.</p>"},{"location":"schema/axes/#grid-plans","title":"Grid Plans","text":"<p>Ways to describe a grid acquisition sequence.</p>"},{"location":"schema/axes/#useq.GridRowsColumns","title":"<code>GridRowsColumns</code>","text":"<p>Grid plan based on number of rows and columns.</p> <p>Attributes:</p> Name Type Description <code>rows</code> <code>int</code> <p>Number of rows.</p> <code>columns</code> <code>int</code> <p>Number of columns.</p> <code>relative_to</code> <code>RelativeTo</code> <p>Point in the grid to which the coordinates are relative. If \"center\", the grid is centered around the origin. If \"top_left\", the grid is positioned such that the top left corner is at the origin.</p> <code>overlap</code> <code>float | Tuple[float, float]</code> <p>Overlap between grid positions in percent. If a single value is provided, it is used for both x and y. If a tuple is provided, the first value is used for x and the second for y.</p> <code>mode</code> <code>OrderMode</code> <p>Define the ways of ordering the grid positions. Options are row_wise, column_wise, row_wise_snake, column_wise_snake and spiral. By default, row_wise_snake.</p> <code>fov_width</code> <code>Optional[float]</code> <p>Width of the field of view in microns.  If not provided, acquisition engines should use current width of the FOV based on the current objective and camera. Engines MAY override this even if provided.</p> <code>fov_height</code> <code>Optional[float]</code> <p>Height of the field of view in microns. If not provided, acquisition engines should use current height of the FOV based on the current objective and camera. Engines MAY override this even if provided.</p>"},{"location":"schema/axes/#useq.GridWidthHeight","title":"<code>GridWidthHeight</code>","text":"<p>Grid plan based on total width and height.</p> <p>Attributes:</p> Name Type Description <code>width</code> <code>float</code> <p>Minimum total width of the grid, in microns. (may be larger based on fov_width)</p> <code>height</code> <code>float</code> <p>Minimum total height of the grid, in microns. (may be larger based on fov_height)</p> <code>relative_to</code> <code>RelativeTo</code> <p>Point in the grid to which the coordinates are relative. If \"center\", the grid is centered around the origin. If \"top_left\", the grid is positioned such that the top left corner is at the origin.</p> <code>overlap</code> <code>float | Tuple[float, float]</code> <p>Overlap between grid positions in percent. If a single value is provided, it is used for both x and y. If a tuple is provided, the first value is used for x and the second for y.</p> <code>mode</code> <code>OrderMode</code> <p>Define the ways of ordering the grid positions. Options are row_wise, column_wise, row_wise_snake, column_wise_snake and spiral. By default, row_wise_snake.</p> <code>fov_width</code> <code>Optional[float]</code> <p>Width of the field of view in microns.  If not provided, acquisition engines should use current width of the FOV based on the current objective and camera. Engines MAY override this even if provided.</p> <code>fov_height</code> <code>Optional[float]</code> <p>Height of the field of view in microns. If not provided, acquisition engines should use current height of the FOV based on the current objective and camera. Engines MAY override this even if provided.</p>"},{"location":"schema/axes/#useq.GridFromEdges","title":"<code>GridFromEdges</code>","text":"<p>Yield absolute stage positions to cover a bounded area.</p> <p>The bounded area is defined by top, left, bottom and right edges in stage coordinates.  The bounds define the outer edges of the images, including the field of view and overlap.</p> <p>Attributes:</p> Name Type Description <code>top</code> <code>float</code> <p>Top stage position of the bounding area</p> <code>left</code> <code>float</code> <p>Left stage position of the bounding area</p> <code>bottom</code> <code>float</code> <p>Bottom stage position of the bounding area</p> <code>right</code> <code>float</code> <p>Right stage position of the bounding area</p> <code>overlap</code> <code>float | Tuple[float, float]</code> <p>Overlap between grid positions in percent. If a single value is provided, it is used for both x and y. If a tuple is provided, the first value is used for x and the second for y.</p> <code>mode</code> <code>OrderMode</code> <p>Define the ways of ordering the grid positions. Options are row_wise, column_wise, row_wise_snake, column_wise_snake and spiral. By default, row_wise_snake.</p> <code>fov_width</code> <code>Optional[float]</code> <p>Width of the field of view in microns.  If not provided, acquisition engines should use current width of the FOV based on the current objective and camera. Engines MAY override this even if provided.</p> <code>fov_height</code> <code>Optional[float]</code> <p>Height of the field of view in microns. If not provided, acquisition engines should use current height of the FOV based on the current objective and camera. Engines MAY override this even if provided.</p>"},{"location":"schema/axes/#useq.RandomPoints","title":"<code>RandomPoints</code>","text":"<p>Yield random points in a specified geometric shape.</p> <p>Attributes:</p> Name Type Description <code>num_points</code> <code>int</code> <p>Number of points to generate.</p> <code>max_width</code> <code>float</code> <p>Maximum width of the bounding box in microns.</p> <code>max_height</code> <code>float</code> <p>Maximum height of the bounding box in microns.</p> <code>shape</code> <code>Shape</code> <p>Shape of the bounding box. Current options are \"ellipse\" and \"rectangle\".</p> <code>random_seed</code> <code>Optional[int]</code> <p>Random numpy seed that should be used to generate the points. If None, a random seed will be used.</p> <code>allow_overlap</code> <code>bool</code> <p>By defaut, True. If False and <code>fov_width</code> and <code>fov_height</code> are specified, points will not overlap and will be at least <code>fov_width</code> and `fov_height apart.</p> <code>order</code> <code>TraversalOrder</code> <p>Order in which the points will be visited. If None, order is simply the order in which the points are generated (random).  Use 'nearest_neighbor' or 'two_opt' to order the points in a more structured way.</p> <code>start_at</code> <code>int | RelativePosition</code> <p>Position or index of the point to start at. This is only used if <code>order</code> is 'nearest_neighbor' or 'two_opt'.  If a position is provided, it will always be included in the list of points. If an index is provided, it must be less than the number of points, and corresponds to the index of the (randomly generated) points; this likely only makes sense when <code>random_seed</code> is provided.</p>"},{"location":"schema/axes/#useq._grid.RelativeTo","title":"<code>RelativeTo</code>","text":"<p>Where the coordinates of the grid are relative to.</p> <p>Attributes:</p> Name Type Description <code>center</code> <code>Literal['center']</code> <p>Grid is centered around the origin.</p> <code>top_left</code> <code>Literal['top_left']</code> <p>Grid is positioned such that the top left corner is at the origin.</p>"},{"location":"schema/axes/#useq._grid.OrderMode","title":"<code>OrderMode</code>","text":"<p>Order in which grid positions will be iterated.</p> <p>Attributes:</p> Name Type Description <code>row_wise</code> <code>Literal['row_wise']</code> <p>Iterate row by row.</p> <code>column_wise</code> <code>Literal['column_wise']</code> <p>Iterate column by column.</p> <code>row_wise_snake</code> <code>Literal['row_wise_snake']</code> <p>Iterate row by row, but alternate the direction of the columns.</p> <code>column_wise_snake</code> <code>Literal['column_wise_snake']</code> <p>Iterate column by column, but alternate the direction of the rows.</p> <code>spiral</code> <code>Literal['spiral']</code> <p>Iterate in a spiral pattern, starting from the center.</p>"},{"location":"schema/axes/#useq._grid.OrderMode.generate_indices","title":"<code>generate_indices</code>","text":"<p>Generate indices for the given grid size.</p>"},{"location":"schema/axes/#useq._grid.Shape","title":"<code>Shape</code>","text":"<p>Shape of the bounding box for random points.</p> <p>Attributes:</p> Name Type Description <code>ELLIPSE</code> <code>Literal['ellipse']</code> <p>The bounding box is an ellipse.</p> <code>RECTANGLE</code> <code>Literal['rectangle']</code> <p>The bounding box is a rectangle.</p>"},{"location":"schema/event/","title":"Event","text":""},{"location":"schema/event/#useq.MDAEvent","title":"<code>MDAEvent</code>","text":"<p>Define a single event in a <code>MDASequence</code>.</p> <p>Usually, this object will be generator by iterating over a <code>MDASequence</code> (see <code>useq.MDASequence.iter_events</code>).</p> <p>Attributes:</p> Name Type Description <code>index</code> <code>dict[str, int]</code> <p>Index of this event in the sequence. This is a mapping of axis name to index.  For example: <code>{'t': 4, 'c': 0, 'z': 5},</code></p> <code>channel</code> <code>Channel | None</code> <p>Channel to use for this event. If <code>None</code>, implies use current channel. By default, <code>None</code>.  <code>Channel</code> is a simple pydantic object with two attributes: <code>config</code> and <code>group</code>.  <code>config</code> is the name of the configuration to use for this channel, (e.g. <code>\"488nm\"</code>, <code>\"DAPI\"</code>, <code>\"FITC\"</code>).  <code>group</code> is the name of the group to which this channel belongs. By default, <code>\"Channel\"</code>.</p> <code>exposure</code> <code>float | None</code> <p>Exposure time in milliseconds. If not provided, implies use current exposure time. By default, <code>None</code>.</p> <code>min_start_time</code> <code>float | None</code> <p>Minimum start time of this event, in seconds.  If provided, the engine will pause until this time has elapsed before starting this event. Times are relative to the start of the sequence, or the last event with <code>reset_event_timer</code> set to <code>True</code>.</p> <code>pos_name</code> <code>str | None</code> <p>The name assigned to the position. By default, <code>None</code>.</p> <code>x_pos</code> <code>float | None</code> <p>X position in microns. If not provided, implies use current position. By default, <code>None</code>.</p> <code>y_pos</code> <code>float | None</code> <p>Y position in microns. If not provided, implies use current position. By default, <code>None</code>.</p> <code>z_pos</code> <code>float | None</code> <p>Z position in microns. If not provided, implies use current position. By default, <code>None</code>.</p> <code>slm_image</code> <code>SLMImage | None</code> <p>Image data to display on an SLM device. <code>SLMImage</code> is a simple pydantic object with two attributes: <code>data</code> and <code>device</code>. <code>data</code> is the image data (anything that can be cast to a numpy array), <code>device</code> is the name of the SLM device to use. If not provided, the \"default\" SLM device should be used. By default, <code>None</code>.</p> <code>sequence</code> <code>MDASequence | None</code> <p>A reference to the <code>useq.MDASequence</code> this event belongs to. This is a read-only attribute. By default, <code>None</code>.</p> <code>properties</code> <code>Sequence[PropertyTuple] | None</code> <p>List of <code>useq.PropertyTuple</code> to set before starting this event. Where each item in the list is a 3-member named tuple of <code>(device_name, property_name, property_value)</code>.  This is inspired by micro-manager's Device Adapter API, but could be used to set arbitrary properties in any backend that supports the concept of devices that have properties with values. By default, <code>None</code>.</p> <code>metadata</code> <code>dict</code> <p>Optional metadata to be associated with this event.</p> <code>action</code> <code>Action</code> <p>The action to perform for this event.  By default, <code>useq.AcquireImage</code>. Example of another action is <code>useq.HardwareAutofocus</code> which could be used to perform a hardware autofocus.  For backwards compatibility, an <code>action</code> of <code>None</code> implies <code>AcquireImage</code>.  You may use <code>CustomAction</code> to indicate any custom action, with the <code>data</code> attribute containing any data required to perform the custom action.</p> <code>keep_shutter_open</code> <code>bool</code> <p>If <code>True</code>, the illumination shutter should be left open after the event has been executed, otherwise it should be closed. By default, <code>False</code>.\" This is useful when the sequence of events being executed use the same illumination scheme (such as a z-stack in a single channel), and closing and opening the shutter between events would be slow.</p> <code>reset_event_timer</code> <code>bool</code> <p>If <code>True</code>, the engine should reset the event timer to the time of this event, and future <code>min_start_time</code> values will be relative to this event. By default, <code>False</code>.</p>"},{"location":"schema/event/#useq._mda_event.Channel","title":"<code>Channel</code>","text":"<p>Channel in a MDA event.</p> <p>Attributes:</p> Name Type Description <code>config</code> <code>str</code> <p>Name of the configuration to use for this channel, (e.g. <code>\"488nm\"</code>, <code>\"DAPI\"</code>, <code>\"FITC\"</code>).</p> <code>group</code> <code>str</code> <p>Optional name of the group to which this channel belongs. By default, <code>\"Channel\"</code>.</p>"},{"location":"schema/event/#useq.PropertyTuple","title":"<code>PropertyTuple</code>","text":"<p>Three-tuple capturing a device, property, and value.</p> <p>Attributes:</p> Name Type Description <code>device_name</code> <code>str</code> <p>Name of a device.</p> <code>property_name</code> <code>str</code> <p>Name of a property recognized by the device.</p> <code>value</code> <code>Any</code> <p>Value for the property.</p>"},{"location":"schema/event/#event-actions","title":"Event Actions","text":""},{"location":"schema/event/#useq.Action","title":"<code>Action</code>","text":"<p>Base class for a <code>useq.MDAEvent</code> action.</p> <p>An <code>Action</code> specifies what task should be performed during a <code>useq.MDAEvent</code>. An <code>Action</code> can be for example used to acquire an image (<code>useq.AcquireImage</code>) or to perform a hardware autofocus (<code>useq.HardwareAutofocus</code>).  An action of <code>None</code> implies <code>AcquireImage</code>.</p> <p>You may use <code>CustomAction</code> to indicate any custom action, with the <code>data</code> attribute containing any data required to perform the custom action.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>str</code> <p>Type of the action that should be performed at the <code>useq.MDAEvent</code>.</p>"},{"location":"schema/event/#useq.AcquireImage","title":"<code>AcquireImage</code>","text":"<p><code>useq.Action</code> to acquire an image.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>Literal['acquire_image']</code> <p>This action can be used to acquire an image.</p>"},{"location":"schema/event/#useq.HardwareAutofocus","title":"<code>HardwareAutofocus</code>","text":"<p><code>useq.Action</code> to perform a hardware autofocus.</p> <p>See also <code>useq.AutoFocusPlan</code>.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>Literal['hardware_autofocus']</code> <p>This action can be used to trigger hardware autofocus.</p> <code>autofocus_device_name</code> <code>(str, optional)</code> <p>The name of the autofocus offset motor device (if applicable).  If <code>None</code>, acquisition engines may attempt to set the offset however they see fit (such as using a current or default autofocus device.)</p> <code>autofocus_motor_offset</code> <code>(float, optional)</code> <p>Before autofocus is performed, the autofocus motor should be moved to this offset, if applicable. (Not all autofocus devices have an offset motor.) If None, the autofocus motor should not be moved.</p> <code>max_retries</code> <code>int</code> <p>The number of retries if autofocus fails. By default, 3.</p>"},{"location":"schema/hardware_autofocus/","title":"Hardware Autofocus Plan","text":"<p>Ways to describe a hardware-based autofocus plan.</p>"},{"location":"schema/hardware_autofocus/#useq.AutoFocusPlan","title":"<code>AutoFocusPlan</code>","text":"<p>Base class for hardware autofocus plans.</p> <p>Attributes:</p> Name Type Description <code>autofocus_device_name</code> <code>str | None</code> <p>Optional name of the offset motor device.  If <code>None</code>, acquisition engines may attempt to set the offset however they see fit (such as using a current or default autofocus device.)</p> <code>autofocus_motor_offset</code> <code>float | None</code> <p>Before autofocus is performed, the autofocus motor should be moved to this offset, if applicable. (Not all autofocus devices have an offset motor.) If None, the autofocus motor should not be moved.</p>"},{"location":"schema/hardware_autofocus/#useq.AutoFocusPlan.as_action","title":"<code>as_action() -&gt; HardwareAutofocus</code>","text":"<p>Return a <code>useq.HardwareAutofocus</code> for this autofocus plan.</p>"},{"location":"schema/hardware_autofocus/#useq.AutoFocusPlan.event","title":"<code>event(event: MDAEvent) -&gt; MDAEvent | None</code>","text":"<p>Return an autofocus <code>useq.MDAEvent</code> if autofocus should be performed.</p> <p>The z position of the new <code>useq.MDAEvent</code> is also updated if a relative zplan is provided since autofocus shuld be performed on the home z stack position.</p>"},{"location":"schema/hardware_autofocus/#useq.AutoFocusPlan.should_autofocus","title":"<code>should_autofocus(event: MDAEvent) -&gt; bool</code>","text":"<p>Method that must be implemented by a subclass.</p> <p>Should return True if autofocus should be performed (see <code>useq.AxesBasedAF</code>).</p>"},{"location":"schema/hardware_autofocus/#useq.AxesBasedAF","title":"<code>AxesBasedAF</code>","text":"<p>Autofocus plan that performs autofocus when any of the specified axes change.</p> <p>Attributes:</p> Name Type Description <code>axes</code> <code>Tuple[str, ...]</code> <p>Tuple of axis label to use for hardware autofocus.  At every event in which any axis in this tuple is change, autofocus will be performed.  For example, if <code>axes</code> is <code>('p',)</code> then autofocus will be performed every time the <code>p</code> axis is change, (in other words: every time the position is changed.).</p> Source code in <code>src/useq/_hardware_autofocus.py</code> <pre><code>class AxesBasedAF(AutoFocusPlan):\n    \"\"\"Autofocus plan that performs autofocus when any of the specified axes change.\n\n    Attributes\n    ----------\n    axes : Tuple[str, ...]\n        Tuple of axis label to use for hardware autofocus.  At every event in which\n        *any* axis in this tuple is change, autofocus will be performed.  For example,\n        if `axes` is `('p',)` then autofocus will be performed every time the `p` axis\n        is change, (in other words: every time the position is changed.).\n    \"\"\"\n\n    axes: tuple[str, ...]\n    _previous: dict = PrivateAttr(default_factory=dict)\n\n    def should_autofocus(self, event: MDAEvent) -&gt; bool:\n        \"\"\"Return `True` if autofocus should be performed at this event.\n\n        Will return `True` if any of the axes specified in `axes` have changed from the\n        previous event.\n        \"\"\"\n        self._previous, previous = dict(event.index), self._previous\n        return any(\n            axis in self.axes and previous.get(axis) != index\n            for axis, index in event.index.items()\n        )\n</code></pre>"},{"location":"schema/hardware_autofocus/#useq.AxesBasedAF.should_autofocus","title":"<code>should_autofocus(event: MDAEvent) -&gt; bool</code>","text":"<p>Return <code>True</code> if autofocus should be performed at this event.</p> <p>Will return <code>True</code> if any of the axes specified in <code>axes</code> have changed from the previous event.</p> Source code in <code>src/useq/_hardware_autofocus.py</code> <pre><code>def should_autofocus(self, event: MDAEvent) -&gt; bool:\n    \"\"\"Return `True` if autofocus should be performed at this event.\n\n    Will return `True` if any of the axes specified in `axes` have changed from the\n    previous event.\n    \"\"\"\n    self._previous, previous = dict(event.index), self._previous\n    return any(\n        axis in self.axes and previous.get(axis) != index\n        for axis, index in event.index.items()\n    )\n</code></pre>"},{"location":"schema/sequence/","title":"Sequence","text":""},{"location":"schema/sequence/#useq.MDASequence","title":"<code>MDASequence</code>","text":"<p>A sequence of MDA (Multi-Dimensional Acquisition) events.</p> <p>This is the core object in the <code>useq</code> library, and is used define a sequence of events to be run on a microscope. It object may be constructed manually, or from file (e.g. json or yaml).</p> <p>The object itself acts as an iterator for <code>useq.MDAEvent</code> objects:</p> <p>Attributes:</p> Name Type Description <code>metadata</code> <code>dict</code> <p>A dictionary of user metadata to be stored with the sequence.</p> <code>axis_order</code> <code>str</code> <p>The order of the axes in the sequence. Must be a permutation of <code>\"tpgcz\"</code>. The default is <code>\"tpgcz\"</code>.</p> <code>stage_positions</code> <code>tuple[Position, ...]</code> <p>The stage positions to visit. (each with <code>x</code>, <code>y</code>, <code>z</code>, <code>name</code>, and <code>sequence</code>, all of which are optional).</p> <code>grid_plan</code> <code>GridFromEdges | GridRelative | None</code> <p>The grid plan to follow. One of <code>GridFromEdges</code>, <code>GridRelative</code> or <code>None</code>.</p> <code>channels</code> <code>tuple[Channel, ...]</code> <p>The channels to acquire. see <code>Channel</code>.</p> <code>time_plan</code> <code>MultiPhaseTimePlan | TIntervalDuration | TIntervalLoops | TDurationLoops | None</code> <p>The time plan to follow. One of <code>TIntervalDuration</code>, <code>TIntervalLoops</code>, <code>TDurationLoops</code>, <code>MultiPhaseTimePlan</code>, or <code>None</code></p> <code>z_plan</code> <code>ZTopBottom | ZRangeAround | ZAboveBelow | ZRelativePositions | ZAbsolutePositions | None</code> <p>The z plan to follow. One of <code>ZTopBottom</code>, <code>ZRangeAround</code>, <code>ZAboveBelow</code>, <code>ZRelativePositions</code>, <code>ZAbsolutePositions</code>, or <code>None</code>.</p> <code>uid</code> <code>UUID</code> <p>A read-only unique identifier (uuid version 4) for the sequence. This will be generated, do not set.</p> <code>autofocus_plan</code> <code>AxesBasedAF | None</code> <p>The hardware autofocus plan to follow. One of <code>AxesBasedAF</code> or <code>None</code>.</p> <code>keep_shutter_open_across</code> <code>tuple[str, ...]</code> <p>A tuple of axes <code>str</code> across which the illumination shutter should be kept open. Resulting events will have <code>keep_shutter_open</code> set to <code>True</code> if and only if ALL axes whose indices are changing are in this tuple. For example, if <code>keep_shutter_open_across=('z',)</code>, then the shutter would be kept open between events axes {'t': 0, 'z: 0} and {'t': 0, 'z': 1}, but not between {'t': 0, 'z': 0} and {'t': 1, 'z': 0}.</p> <p>Examples:</p> <p>Create a MDASequence</p> <pre><code>&gt;&gt;&gt; from useq import MDASequence, Position, Channel, TIntervalDuration\n&gt;&gt;&gt; seq = MDASequence(\n...     axis_order=\"tpgcz\",\n...     time_plan={\"interval\": 0.1, \"loops\": 2},\n...     stage_positions=[(1, 1, 1)],\n...     grid_plan={\"rows\": 2, \"columns\": 2},\n...     z_plan={\"range\": 3, \"step\": 1},\n...     channels=[{\"config\": \"DAPI\", \"exposure\": 1}]\n... )\n</code></pre> <p>Print the sequence to visualize its structure</p> <pre><code>&gt;&gt;&gt; print(seq)\n... MDASequence(\n...     stage_positions=(Position(x=1.0, y=1.0, z=1.0, name=None),),\n...     grid_plan=GridRowsColumns(\n...         fov_width=None,\n...         fov_height=None,\n...         overlap=(0.0, 0.0),\n...         mode=&lt;OrderMode.row_wise_snake: 'row_wise_snake'&gt;,\n...         rows=2,\n...         columns=2,\n...         relative_to=&lt;RelativeTo.center: 'center'&gt;\n...     ),\n...     channels=(\n...         Channel(\n...             config='DAPI',\n...             group='Channel',\n...             exposure=1.0,\n...             do_stack=True,\n...             z_offset=0.0,\n...             acquire_every=1,\n...             camera=None\n...         ),\n...     ),\n...     time_plan=TIntervalLoops(\n...         prioritize_duration=False,\n...         interval=datetime.timedelta(microseconds=100000),\n...         loops=2\n...     ),\n...     z_plan=ZRangeAround(go_up=True, range=3.0, step=1.0)\n... )\n</code></pre> <p>Iterate over the events in the sequence</p> <pre><code>&gt;&gt;&gt; print(list(seq))\n... [\n...     MDAEvent(\n...         index=mappingproxy({'t': 0, 'p': 0, 'g': 0, 'c': 0, 'z': 0}),\n...         channel=Channel(config='DAPI'),\n...         exposure=1.0,\n...         min_start_time=0.0,\n...         x_pos=0.5,\n...         y_pos=1.5,\n...         z_pos=-0.5\n...     ),\n...     MDAEvent(\n...         index=mappingproxy({'t': 0, 'p': 0, 'g': 0, 'c': 0, 'z': 1}),\n...         channel=Channel(config='DAPI'),\n...         exposure=1.0,\n...         min_start_time=0.0,\n...         x_pos=0.5,\n...         y_pos=1.5,\n...         z_pos=0.5\n...     ),\n...     ...\n... ]\n</code></pre> <p>Print the sequence as yaml</p> <pre><code>&gt;&gt;&gt; print(seq.yaml())\n</code></pre> <pre><code>axis_order:\n   - t\n   - p\n   - g\n   - c\n   - z\nchannels:\n   - config: DAPI\n     exposure: 1.0\ngrid_plan:\n   columns: 2\n   rows: 2\nstage_positions:\n   - x: 1.0\n     y: 1.0\n     z: 1.0\ntime_plan:\n   interval: '0:00:00.100000'\n   loops: 2\nz_plan:\n   range: 3.0\n   step: 1.0\n</code></pre>"}]}